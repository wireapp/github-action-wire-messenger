"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const DecodeError_1 = require("./DecodeError");
const Type_1 = require("./Type");
const BYTES_IN_MEGABYTE = 0x100000;
const DEFAULT_CONFIG = {
    max_array_length: 1000,
    max_bytes_length: 5 * BYTES_IN_MEGABYTE,
    max_nesting: 16,
    max_object_size: 1000,
    max_text_length: 5 * BYTES_IN_MEGABYTE,
};
class Decoder {
    constructor(buffer, config = DEFAULT_CONFIG) {
        this.buffer = buffer;
        this.config = config;
        this.view = new DataView(this.buffer);
    }
    static _check_overflow(int, overflow) {
        if (int > overflow) {
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.INT_OVERFLOW);
        }
        return int;
    }
    _advance(bytes) {
        this.view = new DataView(this.buffer, this.view.byteOffset + bytes);
    }
    get _available() {
        return this.view.byteLength;
    }
    _read(bytes, closure) {
        if (this._available < bytes) {
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_EOF);
        }
        const value = closure();
        this._advance(bytes);
        return value;
    }
    /*
     * reader-like interface for @buffer
     */
    _u8() {
        return this._read(1, () => this.view.getUint8(0));
    }
    _u16() {
        return this._read(2, () => this.view.getUint16(0));
    }
    _u32() {
        return this._read(4, () => this.view.getUint32(0));
    }
    _u64() {
        const r64 = () => this.view.getUint32(0) * Math.pow(2, 32) + this.view.getUint32(4);
        return this._read(8, r64);
    }
    _f32() {
        return this._read(4, () => this.view.getFloat32(0));
    }
    _f64() {
        return this._read(8, () => this.view.getFloat64(0));
    }
    _read_length(minor) {
        if (0 <= minor && minor <= 23) {
            return minor;
        }
        switch (minor) {
            case 24:
                return this._u8();
            case 25:
                return this._u16();
            case 26:
                return this._u32();
            case 27:
                return Decoder._check_overflow(this._u64(), Number.MAX_SAFE_INTEGER);
        }
        throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE);
    }
    _bytes(minor, max_len) {
        const len = this._read_length(minor);
        if (len > max_len) {
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.TOO_LONG);
        }
        const callback = () => this.buffer.slice(this.view.byteOffset, this.view.byteOffset + len);
        return this._read(len, callback);
    }
    _read_type_info() {
        const type = this._u8();
        const major = (type & 0xe0) >> 5;
        const minor = type & 0x1f;
        switch (major) {
            case 0: {
                if (0 <= minor && minor <= 24) {
                    return [Type_1.Type.UINT8, minor];
                }
                switch (minor) {
                    case 25:
                        return [Type_1.Type.UINT16, minor];
                    case 26:
                        return [Type_1.Type.UINT32, minor];
                    case 27:
                        return [Type_1.Type.UINT64, minor];
                    default:
                        throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.INVALID_TYPE);
                }
            }
            case 1: {
                if (0 <= minor && minor <= 24) {
                    return [Type_1.Type.INT8, minor];
                }
                switch (minor) {
                    case 25:
                        return [Type_1.Type.INT16, minor];
                    case 26:
                        return [Type_1.Type.INT32, minor];
                    case 27:
                        return [Type_1.Type.INT64, minor];
                    default:
                        throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.INVALID_TYPE);
                }
            }
            case 2:
                return [Type_1.Type.BYTES, minor];
            case 3:
                return [Type_1.Type.TEXT, minor];
            case 4:
                return [Type_1.Type.ARRAY, minor];
            case 5:
                return [Type_1.Type.OBJECT, minor];
            case 7:
                switch (minor) {
                    case 20:
                    case 21:
                        return [Type_1.Type.BOOL, minor];
                    case 22:
                        return [Type_1.Type.NULL, minor];
                    case 23:
                        return [Type_1.Type.UNDEFINED, minor];
                    case 25:
                        return [Type_1.Type.FLOAT16, minor];
                    case 26:
                        return [Type_1.Type.FLOAT32, minor];
                    case 27:
                        return [Type_1.Type.FLOAT64, minor];
                    case 31:
                        return [Type_1.Type.BREAK, minor];
                }
                break;
        }
        throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.INVALID_TYPE);
    }
    _type_info_with_assert(expected) {
        const [type, minor] = this._read_type_info();
        if (!Array.isArray(expected)) {
            expected = [expected];
        }
        const hasExpectedType = expected.some(expectedType => type === expectedType);
        if (!hasExpectedType) {
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE, [type, minor]);
        }
        return [type, minor];
    }
    _read_unsigned(type, minor) {
        switch (type) {
            case Type_1.Type.UINT8:
                return minor <= 23 ? minor : this._u8();
            case Type_1.Type.UINT16:
                return this._u16();
            case Type_1.Type.UINT32:
                return this._u32();
            case Type_1.Type.UINT64:
                return this._u64();
        }
        throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE, [type, minor]);
    }
    _read_signed(overflow, type, minor) {
        switch (type) {
            case Type_1.Type.INT8:
                if (minor <= 23) {
                    return -1 - minor;
                }
                return -1 - Decoder._check_overflow(this._u8(), overflow);
            case Type_1.Type.INT16:
                return -1 - Decoder._check_overflow(this._u16(), overflow);
            case Type_1.Type.INT32:
                return -1 - Decoder._check_overflow(this._u32(), overflow);
            case Type_1.Type.INT64:
                return -1 - Decoder._check_overflow(this._u64(), overflow);
            case Type_1.Type.UINT8:
            case Type_1.Type.UINT16:
            case Type_1.Type.UINT32:
            case Type_1.Type.UINT64:
                return Decoder._check_overflow(this._read_unsigned(type, minor), overflow);
        }
        throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE, [type, minor]);
    }
    _skip_until_break(type) {
        for (;;) {
            const [t, minor] = this._read_type_info();
            if (t === Type_1.Type.BREAK) {
                return;
            }
            if (t !== type || minor === 31) {
                throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE);
            }
            const len = this._read_length(minor);
            this._advance(len);
        }
    }
    _skip_value(level) {
        if (level === 0) {
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.TOO_NESTED);
        }
        const [type, minor] = this._read_type_info();
        let len;
        switch (type) {
            case Type_1.Type.UINT8:
            case Type_1.Type.UINT16:
            case Type_1.Type.UINT32:
            case Type_1.Type.UINT64:
            case Type_1.Type.INT8:
            case Type_1.Type.INT16:
            case Type_1.Type.INT32:
            case Type_1.Type.INT64:
                this._read_length(minor);
                return true;
            case Type_1.Type.BOOL:
            case Type_1.Type.NULL:
            case Type_1.Type.UNDEFINED:
                return true;
            case Type_1.Type.BREAK:
                return false;
            case Type_1.Type.FLOAT16:
                this._advance(2);
                return true;
            case Type_1.Type.FLOAT32:
                this._advance(4);
                return true;
            case Type_1.Type.FLOAT64:
                this._advance(8);
                return true;
            case Type_1.Type.BYTES:
            case Type_1.Type.TEXT:
                if (minor === 31) {
                    this._skip_until_break(type);
                    return true;
                }
                len = this._read_length(minor);
                this._advance(len);
                return true;
            case Type_1.Type.ARRAY:
            case Type_1.Type.OBJECT:
                if (minor === 31) {
                    while (this._skip_value(level - 1)) {
                        // do nothing
                    }
                    return true;
                }
                len = this._read_length(minor);
                while (len--) {
                    this._skip_value(level - 1);
                }
                return true;
            default:
                return false;
        }
    }
    u8() {
        const [type, minor] = this._type_info_with_assert([Type_1.Type.UINT8]);
        return this._read_unsigned(type, minor);
    }
    u16() {
        const [type, minor] = this._type_info_with_assert([Type_1.Type.UINT8, Type_1.Type.UINT16]);
        return this._read_unsigned(type, minor);
    }
    u32() {
        const [type, minor] = this._type_info_with_assert([Type_1.Type.UINT8, Type_1.Type.UINT16, Type_1.Type.UINT32]);
        return this._read_unsigned(type, minor);
    }
    u64() {
        const [type, minor] = this._type_info_with_assert([Type_1.Type.UINT8, Type_1.Type.UINT16, Type_1.Type.UINT32, Type_1.Type.UINT64]);
        return this._read_unsigned(type, minor);
    }
    i8() {
        const [type, minor] = this._type_info_with_assert([Type_1.Type.INT8, Type_1.Type.UINT8]);
        return this._read_signed(127, type, minor);
    }
    i16() {
        const [type, minor] = this._type_info_with_assert([Type_1.Type.INT8, Type_1.Type.INT16, Type_1.Type.UINT8, Type_1.Type.UINT16]);
        return this._read_signed(32767, type, minor);
    }
    i32() {
        const [type, minor] = this._type_info_with_assert([
            Type_1.Type.INT8,
            Type_1.Type.INT16,
            Type_1.Type.INT32,
            Type_1.Type.UINT8,
            Type_1.Type.UINT16,
            Type_1.Type.UINT32,
        ]);
        return this._read_signed(2147483647, type, minor);
    }
    i64() {
        const [type, minor] = this._type_info_with_assert([
            Type_1.Type.INT8,
            Type_1.Type.INT16,
            Type_1.Type.INT32,
            Type_1.Type.INT64,
            Type_1.Type.UINT8,
            Type_1.Type.UINT16,
            Type_1.Type.UINT32,
            Type_1.Type.UINT64,
        ]);
        return this._read_signed(Number.MAX_SAFE_INTEGER, type, minor);
    }
    unsigned() {
        return this.u64();
    }
    int() {
        return this.i64();
    }
    f16() {
        this._type_info_with_assert(Type_1.Type.FLOAT16);
        const half = this._u16();
        const exp = (half >> 10) & 0x1f;
        const mant = half & 0x3ff;
        const ldexp = (significand, exponent) => significand * Math.pow(2, exponent);
        let val;
        switch (exp) {
            case 0:
                val = ldexp(mant, -24);
                break;
            case 31:
                val = mant === 0 ? Number.POSITIVE_INFINITY : Number.NaN;
                break;
            default:
                val = ldexp(mant + 1024, exp - 25);
                break;
        }
        return half & 0x8000 ? -val : val;
    }
    f32() {
        this._type_info_with_assert(Type_1.Type.FLOAT32);
        return this._f32();
    }
    f64() {
        this._type_info_with_assert(Type_1.Type.FLOAT64);
        return this._f64();
    }
    bool() {
        const minor = this._type_info_with_assert(Type_1.Type.BOOL)[1];
        switch (minor) {
            case 20:
                return false;
            case 21:
                return true;
            default:
                throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE);
        }
    }
    bytes() {
        const minor = this._type_info_with_assert(Type_1.Type.BYTES)[1];
        if (minor === 31) {
            // XXX: handle indefinite encoding
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE);
        }
        return this._bytes(minor, this.config.max_bytes_length);
    }
    text() {
        const minor = this._type_info_with_assert(Type_1.Type.TEXT)[1];
        if (minor === 31) {
            // XXX: handle indefinite encoding
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE);
        }
        const array = new Uint8Array(this._bytes(minor, this.config.max_text_length));
        const utf8 = array.reduce((previousValue, char) => previousValue + String.fromCharCode(char), '');
        // http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html
        return decodeURIComponent(escape(utf8));
    }
    optional(closure) {
        try {
            const result = closure();
            return result;
        }
        catch (error) {
            if (error instanceof DecodeError_1.DecodeError && error.extra) {
                const type = error.extra[0];
                if (type === Type_1.Type.NULL) {
                    return null;
                }
                else if (type === Type_1.Type.UNDEFINED) {
                    return undefined;
                }
            }
            throw error;
        }
    }
    array() {
        const minor = this._type_info_with_assert(Type_1.Type.ARRAY)[1];
        if (minor === 31) {
            // XXX: handle indefinite encoding
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE);
        }
        const len = this._read_length(minor);
        if (len > this.config.max_array_length) {
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.TOO_LONG);
        }
        return len;
    }
    object() {
        const minor = this._type_info_with_assert(Type_1.Type.OBJECT)[1];
        if (minor === 31) {
            // XXX: handle indefinite encoding
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.UNEXPECTED_TYPE);
        }
        const len = this._read_length(minor);
        if (len > this.config.max_object_size) {
            throw new DecodeError_1.DecodeError(DecodeError_1.DecodeError.TOO_LONG);
        }
        return len;
    }
    skip() {
        return this._skip_value(this.config.max_nesting);
    }
}
exports.Decoder = Decoder;
//# sourceMappingURL=Decoder.js.map