"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const sodium = require("libsodium-wrappers-sumo");
const DecodeError_1 = require("../errors/DecodeError");
const InputError_1 = require("../errors/InputError");
const PublicKey_1 = require("./PublicKey");
const SecretKey_1 = require("./SecretKey");
class KeyPair {
    constructor(publicKey, secretKey) {
        if (publicKey && secretKey) {
            this.public_key = publicKey;
            this.secret_key = secretKey;
        }
        else {
            const ed25519KeyPair = sodium.crypto_sign_keypair();
            this.public_key = KeyPair.construct_public_key(ed25519KeyPair);
            this.secret_key = KeyPair.construct_private_key(ed25519KeyPair);
        }
    }
    static construct_private_key(ed25519_key_pair) {
        try {
            const sk_ed25519 = ed25519_key_pair.privateKey;
            const sk_curve25519 = sodium.crypto_sign_ed25519_sk_to_curve25519(sk_ed25519);
            return new SecretKey_1.SecretKey(sk_ed25519, sk_curve25519);
        }
        catch (error) {
            throw new InputError_1.InputError.ConversionError('Could not convert secret key with libsodium.', 409);
        }
    }
    static construct_public_key(ed25519_key_pair) {
        try {
            const pk_ed25519 = ed25519_key_pair.publicKey;
            const pk_curve25519 = sodium.crypto_sign_ed25519_pk_to_curve25519(pk_ed25519);
            return new PublicKey_1.PublicKey(pk_ed25519, pk_curve25519);
        }
        catch (error) {
            throw new InputError_1.InputError.ConversionError('Could not convert public key with libsodium.', 408);
        }
    }
    static encode(encoder, keyPair) {
        encoder.object(KeyPair.propertiesLength);
        encoder.u8(0);
        SecretKey_1.SecretKey.encode(encoder, keyPair.secret_key);
        encoder.u8(1);
        PublicKey_1.PublicKey.encode(encoder, keyPair.public_key);
        return encoder;
    }
    static decode(decoder) {
        const propertiesLength = decoder.object();
        if (propertiesLength === KeyPair.propertiesLength) {
            decoder.u8();
            const secretKey = SecretKey_1.SecretKey.decode(decoder);
            decoder.u8();
            const publicKey = PublicKey_1.PublicKey.decode(decoder);
            return new KeyPair(publicKey, secretKey);
        }
        throw new DecodeError_1.DecodeError(`Unexpected number of properties: "${propertiesLength}"`);
    }
}
exports.KeyPair = KeyPair;
KeyPair.propertiesLength = 2;
//# sourceMappingURL=KeyPair.js.map