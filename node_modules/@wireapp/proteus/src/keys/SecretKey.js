"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecretKey = void 0;
const sodium = require("libsodium-wrappers-sumo");
const DecodeError_1 = require("../errors/DecodeError");
const InputError_1 = require("../errors/InputError");
const ArrayUtil_1 = require("../util/ArrayUtil");
class SecretKey {
    constructor(secEdward, secCurve) {
        this.sec_edward = secEdward;
        this.sec_curve = secCurve;
    }
    sign(message) {
        return sodium.crypto_sign_detached(message, this.sec_edward);
    }
    static shared_secret(publicKey, secretKey) {
        const sharedSecret = sodium.crypto_scalarmult(secretKey.sec_curve, publicKey.pub_curve);
        ArrayUtil_1.assert_is_not_zeros(sharedSecret);
        return sharedSecret;
    }
    static encode(encoder, secretKey) {
        encoder.object(SecretKey.propertiesLength);
        encoder.u8(0);
        return encoder.bytes(secretKey.sec_edward);
    }
    static decode(decoder) {
        const propertiesLength = decoder.object();
        if (propertiesLength === SecretKey.propertiesLength) {
            decoder.u8();
            const secEdward = new Uint8Array(decoder.bytes());
            try {
                const secCurve = sodium.crypto_sign_ed25519_sk_to_curve25519(secEdward);
                return new SecretKey(secEdward, secCurve);
            }
            catch (error) {
                throw new InputError_1.InputError.ConversionError('Could not convert secret key with libsodium.', 408);
            }
        }
        throw new DecodeError_1.DecodeError(`Unexpected number of properties: "${propertiesLength}"`);
    }
}
exports.SecretKey = SecretKey;
SecretKey.propertiesLength = 1;
//# sourceMappingURL=SecretKey.js.map