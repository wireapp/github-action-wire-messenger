"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hkdf = void 0;
const sodium = require("libsodium-wrappers-sumo");
const MemoryUtil_1 = require("./MemoryUtil");
const ArrayUtil_1 = require("./ArrayUtil");
function hkdf(salt, input, info, length) {
    const convertType = (value) => {
        if (typeof value === 'string') {
            return sodium.from_string(value);
        }
        return value;
    };
    salt = convertType(salt);
    input = convertType(input);
    info = convertType(info);
    const HASH_LEN = 32;
    const saltToKey = (receivedSalt) => {
        const keybytes = sodium.crypto_auth_hmacsha256_KEYBYTES;
        if (receivedSalt.length > keybytes) {
            return sodium.crypto_hash_sha256(receivedSalt);
        }
        const key = new Uint8Array(keybytes);
        key.set(receivedSalt);
        return key;
    };
    const extract = (receivedSalt, receivedInput) => {
        return sodium.crypto_auth_hmacsha256(receivedInput, saltToKey(receivedSalt));
    };
    const expand = (tag, receivedInfo, receivedLength) => {
        const numBlocks = Math.ceil(receivedLength / HASH_LEN);
        let hmac = new Uint8Array(0);
        let result = new Uint8Array(0);
        for (let index = 0; index <= numBlocks - 1; index++) {
            const buf = ArrayUtil_1.concatenate_array_buffers([hmac, receivedInfo, new Uint8Array([index + 1])]);
            hmac = sodium.crypto_auth_hmacsha256(buf, tag);
            result = ArrayUtil_1.concatenate_array_buffers([result, hmac]);
        }
        return new Uint8Array(result.buffer.slice(0, receivedLength));
    };
    const key = extract(salt, input);
    MemoryUtil_1.zeroize(input);
    MemoryUtil_1.zeroize(salt);
    return expand(key, info, length);
}
exports.hkdf = hkdf;
//# sourceMappingURL=KeyDerivationUtil.js.map