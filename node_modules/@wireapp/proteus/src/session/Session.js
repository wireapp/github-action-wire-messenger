"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const cbor_1 = require("@wireapp/cbor");
const SessionState_1 = require("./SessionState");
const SessionTag_1 = require("../message/SessionTag");
const IdentityKey_1 = require("../keys/IdentityKey");
const PublicKey_1 = require("../keys/PublicKey");
const CipherMessage_1 = require("../message/CipherMessage");
const DecryptError_1 = require("../errors/DecryptError");
const PreKey_1 = require("../keys/PreKey");
const PreKeyMessage_1 = require("../message/PreKeyMessage");
const MemoryUtil_1 = require("../util/MemoryUtil");
const ProteusError_1 = require("../errors/ProteusError");
const KeyPair_1 = require("../keys/KeyPair");
const DecodeError_1 = require("../errors/DecodeError");
class Session {
    constructor(localIdentity, remoteIdentity, sessionTag = new SessionTag_1.SessionTag(), pendingPrekey = null, sessionStates = {}, version = 1) {
        this.local_identity = localIdentity;
        this.pending_prekey = pendingPrekey;
        this.remote_identity = remoteIdentity;
        this.session_states = sessionStates;
        this.session_tag = sessionTag;
        this.session_tag_name = sessionTag.toString();
        this.version = version;
        this.counter = 0;
    }
    static init_from_prekey(local_identity, remote_pkbundle) {
        const alice_base = new KeyPair_1.KeyPair();
        const state = SessionState_1.SessionState.init_as_alice(local_identity, alice_base, remote_pkbundle);
        const session_tag = new SessionTag_1.SessionTag();
        const pendingPrekey = [remote_pkbundle.prekey_id, alice_base.public_key];
        const session = new Session(local_identity, remote_pkbundle.identity_key, session_tag, pendingPrekey);
        session._insert_session_state(session_tag, state);
        return session;
    }
    static async init_from_message(ourIdentity, prekey_store, envelope) {
        const preKeyMessage = envelope.message;
        if (preKeyMessage instanceof CipherMessage_1.CipherMessage) {
            throw new DecryptError_1.DecryptError.InvalidMessage("Can't initialise a session from a CipherMessage.", DecryptError_1.DecryptError.CODE.CASE_201);
        }
        if (preKeyMessage instanceof PreKeyMessage_1.PreKeyMessage) {
            const session = new Session(ourIdentity, preKeyMessage.identity_key, preKeyMessage.message.session_tag);
            const state = await session._new_state(prekey_store, preKeyMessage);
            const plain = state.decrypt(envelope, preKeyMessage.message);
            session._insert_session_state(preKeyMessage.message.session_tag, state);
            if (preKeyMessage.prekey_id < PreKey_1.PreKey.MAX_PREKEY_ID) {
                const prekey = await prekey_store.load_prekey(preKeyMessage.prekey_id);
                MemoryUtil_1.zeroize(prekey);
                try {
                    await prekey_store.delete_prekey(preKeyMessage.prekey_id);
                }
                catch (error) {
                    throw new DecryptError_1.DecryptError.PrekeyNotFound(`Could not delete PreKey: ${error.message}`, DecryptError_1.DecryptError.CODE.CASE_203);
                }
            }
            return [session, plain];
        }
        throw new DecryptError_1.DecryptError.InvalidMessage('Unknown message format: The message is neither a "CipherMessage" nor a "PreKeyMessage".', DecryptError_1.DecryptError.CODE.CASE_202);
    }
    async _new_state(preKeyStore, preKeyMessage) {
        try {
            const pre_key = await preKeyStore.load_prekey(preKeyMessage.prekey_id);
            return SessionState_1.SessionState.init_as_bob(this.local_identity, pre_key.key_pair, preKeyMessage.identity_key, preKeyMessage.base_key);
        }
        catch (error) {
            throw new ProteusError_1.ProteusError(`Unable to find PreKey with ID "${preKeyMessage.prekey_id}" in PreKey store "${preKeyStore.constructor.name}".`, ProteusError_1.ProteusError.CODE.CASE_101);
        }
    }
    _insert_session_state(sessionTag, state) {
        const sessionTagName = sessionTag.toString();
        if (this.session_states.hasOwnProperty(sessionTagName)) {
            this.session_states[sessionTagName].state = state;
        }
        else {
            if (this.counter >= Number.MAX_SAFE_INTEGER) {
                this.session_states = {};
                this.counter = 0;
            }
            this.session_states[sessionTagName] = {
                idx: this.counter,
                state,
                tag: sessionTag,
            };
            this.counter++;
        }
        if (this.session_tag_name !== sessionTagName) {
            this.session_tag = sessionTag;
            this.session_tag_name = sessionTagName;
        }
        if (Object.keys(this.session_states).length < Session.MAX_SESSION_STATES) {
            return;
        }
        return this._evict_oldest_session_state();
    }
    _evict_oldest_session_state() {
        const oldest = Object.keys(this.session_states)
            .filter(sessionTagName => sessionTagName.toString() !== this.session_tag_name)
            .reduce((lowest, obj) => {
            return this.session_states[obj].idx < this.session_states[lowest].idx ? obj.toString() : lowest;
        });
        MemoryUtil_1.zeroize(this.session_states[oldest]);
        delete this.session_states[oldest];
    }
    get_local_identity() {
        return this.local_identity.public_key;
    }
    static encrypt(session, plaintext) {
        const session_state = session.session_states[session.session_tag_name];
        if (!session_state) {
            throw new ProteusError_1.ProteusError(`Could not find session for tag '${(session.session_tag || '').toString()}'.`, ProteusError_1.ProteusError.CODE.CASE_102);
        }
        return SessionState_1.SessionState.encrypt(session_state.state, session.local_identity.public_key, session.pending_prekey, session.session_tag, plaintext);
    }
    async decrypt(prekey_store, envelope) {
        const { message } = envelope;
        if (message instanceof CipherMessage_1.CipherMessage) {
            return this._decrypt_cipher_message(envelope, message);
        }
        if (message instanceof PreKeyMessage_1.PreKeyMessage) {
            const actual_fingerprint = message.identity_key.fingerprint();
            const expected_fingerprint = this.remote_identity.fingerprint();
            if (actual_fingerprint !== expected_fingerprint) {
                const message = `Fingerprints do not match: We expected '${expected_fingerprint}', but received '${actual_fingerprint}'.`;
                throw new DecryptError_1.DecryptError.RemoteIdentityChanged(message, DecryptError_1.DecryptError.CODE.CASE_204);
            }
            return this._decrypt_prekey_message(envelope, message, prekey_store);
        }
        throw new DecryptError_1.DecryptError('Unknown message type.', DecryptError_1.DecryptError.CODE.CASE_200);
    }
    async _decrypt_prekey_message(envelope, msg, prekey_store) {
        try {
            const plaintext = this._decrypt_cipher_message(envelope, msg.message);
            return plaintext;
        }
        catch (error) {
            if (error instanceof DecryptError_1.DecryptError.InvalidSignature || error instanceof DecryptError_1.DecryptError.InvalidMessage) {
                const state = await this._new_state(prekey_store, msg);
                const plaintext = state.decrypt(envelope, msg.message);
                if (msg.prekey_id !== PreKey_1.PreKey.MAX_PREKEY_ID) {
                    const prekey = await prekey_store.load_prekey(msg.prekey_id);
                    MemoryUtil_1.zeroize(prekey);
                    await prekey_store.delete_prekey(msg.prekey_id);
                }
                this._insert_session_state(msg.message.session_tag, state);
                this.pending_prekey = null;
                return plaintext;
            }
            throw error;
        }
    }
    _decrypt_cipher_message(envelope, msg) {
        const state = this.session_states[msg.session_tag.toString()];
        if (!state) {
            throw new DecryptError_1.DecryptError.InvalidMessage(`Local session not found for message session tag '${msg.session_tag}'.`, DecryptError_1.DecryptError.CODE.CASE_205);
        }
        const sessionState = SessionState_1.SessionState.deserialise(state.state.serialise());
        const plaintext = sessionState.decrypt(envelope, msg);
        this.pending_prekey = null;
        this._insert_session_state(msg.session_tag, sessionState);
        return plaintext;
    }
    serialise() {
        const encoder = new cbor_1.Encoder();
        Session.encode(encoder, this);
        return encoder.get_buffer();
    }
    static deserialise(local_identity, buf) {
        const decoder = new cbor_1.Decoder(buf);
        return Session.decode(local_identity, decoder);
    }
    static encode(encoder, session) {
        encoder.object(6);
        encoder.u8(0);
        encoder.u8(session.version);
        encoder.u8(1);
        SessionTag_1.SessionTag.encode(encoder, session.session_tag);
        encoder.u8(2);
        IdentityKey_1.IdentityKey.encode(encoder, session.local_identity.public_key);
        encoder.u8(3);
        IdentityKey_1.IdentityKey.encode(encoder, session.remote_identity);
        encoder.u8(4);
        if (session.pending_prekey) {
            encoder.object(2);
            encoder.u8(0);
            encoder.u16(session.pending_prekey[0]);
            encoder.u8(1);
            PublicKey_1.PublicKey.encode(encoder, session.pending_prekey[1]);
        }
        else {
            encoder.null();
        }
        encoder.u8(5);
        const sessionStatesIndices = Object.keys(session.session_states);
        encoder.object(sessionStatesIndices.length);
        for (const sessionStatesIndex of sessionStatesIndices) {
            const state = session.session_states[sessionStatesIndex];
            SessionTag_1.SessionTag.encode(encoder, state.tag);
            SessionState_1.SessionState.encode(encoder, state.state);
        }
    }
    static decode(localIdentity, decoder) {
        let version;
        let sessionTag;
        let remoteIdentity;
        let pendingPrekey;
        let sessionStates = {};
        const propertiesLength = decoder.object();
        for (let index = 0; index <= propertiesLength - 1; index++) {
            switch (decoder.u8()) {
                case 0: {
                    version = decoder.u8();
                    break;
                }
                case 1: {
                    sessionTag = SessionTag_1.SessionTag.decode(decoder);
                    break;
                }
                case 2: {
                    const identity_key = IdentityKey_1.IdentityKey.decode(decoder);
                    if (localIdentity.public_key.fingerprint() !== identity_key.fingerprint()) {
                        throw new DecodeError_1.DecodeError.LocalIdentityChanged(undefined, DecodeError_1.DecodeError.CODE.CASE_300);
                    }
                    localIdentity = localIdentity;
                    break;
                }
                case 3: {
                    remoteIdentity = IdentityKey_1.IdentityKey.decode(decoder);
                    break;
                }
                case 4: {
                    switch (decoder.optional(() => decoder.object())) {
                        case null:
                            pendingPrekey = null;
                            break;
                        case 2:
                            pendingPrekey = [];
                            for (let key = 0; key <= 1; ++key) {
                                switch (decoder.u8()) {
                                    case 0:
                                        pendingPrekey[0] = decoder.u16();
                                        break;
                                    case 1:
                                        pendingPrekey[1] = PublicKey_1.PublicKey.decode(decoder);
                                        break;
                                }
                            }
                            break;
                        default:
                            throw new DecodeError_1.DecodeError.InvalidType(undefined, DecodeError_1.DecodeError.CODE.CASE_301);
                    }
                    break;
                }
                case 5: {
                    sessionStates = {};
                    const nprops = decoder.object();
                    for (let index = 0; index <= nprops - 1; index++) {
                        const tag = SessionTag_1.SessionTag.decode(decoder);
                        sessionStates[tag.toString()] = {
                            idx: index,
                            state: SessionState_1.SessionState.decode(decoder),
                            tag,
                        };
                    }
                    break;
                }
                default: {
                    decoder.skip();
                }
            }
        }
        if (!remoteIdentity) {
            throw new DecodeError_1.DecodeError('Missing remote identity');
        }
        return new Session(localIdentity, remoteIdentity, sessionTag, pendingPrekey, sessionStates, version);
    }
}
exports.Session = Session;
Session.MAX_SESSION_STATES = 100;
//# sourceMappingURL=Session.js.map