"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionState = void 0;
const cbor_1 = require("@wireapp/cbor");
const KeyPair_1 = require("../keys/KeyPair");
const RecvChain_1 = require("./RecvChain");
const RootKey_1 = require("./RootKey");
const SendChain_1 = require("./SendChain");
const ArrayUtil_1 = require("../util/ArrayUtil");
const SecretKey_1 = require("../keys/SecretKey");
const DerivedSecrets_1 = require("../derived/DerivedSecrets");
const ChainKey_1 = require("./ChainKey");
const MemoryUtil_1 = require("../util/MemoryUtil");
const Envelope_1 = require("../message/Envelope");
const CipherMessage_1 = require("../message/CipherMessage");
const PreKeyMessage_1 = require("../message/PreKeyMessage");
const DecryptError_1 = require("../errors/DecryptError");
const DecodeError_1 = require("../errors/DecodeError");
class SessionState {
    constructor(rootKey, sendChain, receiveChains = [], prevCounter = -1) {
        this.prev_counter = prevCounter;
        this.recv_chains = receiveChains;
        this.root_key = rootKey;
        this.send_chain = sendChain;
    }
    static init_as_alice(aliceIdentityPair, aliceBase, bobPreKeyBundle) {
        const masterKey = ArrayUtil_1.concatenate_array_buffers([
            SecretKey_1.SecretKey.shared_secret(bobPreKeyBundle.public_key, aliceIdentityPair.secret_key),
            SecretKey_1.SecretKey.shared_secret(bobPreKeyBundle.identity_key.public_key, aliceBase.secret_key),
            SecretKey_1.SecretKey.shared_secret(bobPreKeyBundle.public_key, aliceBase.secret_key),
        ]);
        const derivedSecrets = DerivedSecrets_1.DerivedSecrets.kdf_without_salt(masterKey, 'handshake');
        MemoryUtil_1.zeroize(masterKey);
        const rootkey = RootKey_1.RootKey.from_cipher_key(derivedSecrets.cipher_key);
        const chainkey = ChainKey_1.ChainKey.from_mac_key(derivedSecrets.mac_key, 0);
        const receiveChains = [new RecvChain_1.RecvChain(chainkey, bobPreKeyBundle.public_key)];
        const sendRatchet = new KeyPair_1.KeyPair();
        const [rootKey, chk] = rootkey.dh_ratchet(sendRatchet, bobPreKeyBundle.public_key);
        const sendChain = new SendChain_1.SendChain(chk, sendRatchet);
        return new SessionState(rootKey, sendChain, receiveChains, 0);
    }
    static init_as_bob(bobIdent, bobPrekey, aliceIdent, aliceBase) {
        const masterKey = ArrayUtil_1.concatenate_array_buffers([
            SecretKey_1.SecretKey.shared_secret(aliceIdent.public_key, bobPrekey.secret_key),
            SecretKey_1.SecretKey.shared_secret(aliceBase, bobIdent.secret_key),
            SecretKey_1.SecretKey.shared_secret(aliceBase, bobPrekey.secret_key),
        ]);
        const derivedSecrets = DerivedSecrets_1.DerivedSecrets.kdf_without_salt(masterKey, 'handshake');
        MemoryUtil_1.zeroize(masterKey);
        const rootkey = RootKey_1.RootKey.from_cipher_key(derivedSecrets.cipher_key);
        const chainkey = ChainKey_1.ChainKey.from_mac_key(derivedSecrets.mac_key, 0);
        const sendChain = new SendChain_1.SendChain(chainkey, bobPrekey);
        return new SessionState(rootkey, sendChain, [], 0);
    }
    ratchet(ratchetKey) {
        const newRatchet = new KeyPair_1.KeyPair();
        const [receiveRootKey, receiveChainKey] = this.root_key.dh_ratchet(this.send_chain.ratchet_key, ratchetKey);
        const [sendRootKey, sendChainKey] = receiveRootKey.dh_ratchet(newRatchet, ratchetKey);
        const receiveChain = new RecvChain_1.RecvChain(receiveChainKey, ratchetKey);
        const sendChain = new SendChain_1.SendChain(sendChainKey, newRatchet);
        this.root_key = sendRootKey;
        this.prev_counter = this.send_chain.chain_key.idx;
        this.send_chain = sendChain;
        this.recv_chains.unshift(receiveChain);
        if (this.recv_chains.length > SessionState.MAX_RECV_CHAINS) {
            for (let index = SessionState.MAX_RECV_CHAINS; index < this.recv_chains.length; index++) {
                MemoryUtil_1.zeroize(this.recv_chains[index]);
            }
            this.recv_chains = this.recv_chains.slice(0, SessionState.MAX_RECV_CHAINS);
        }
    }
    static encrypt(sessionState, identityKey, pending, tag, plaintext) {
        const msgkeys = ChainKey_1.ChainKey.message_keys(sessionState.send_chain.chain_key);
        let message = new CipherMessage_1.CipherMessage(tag, sessionState.send_chain.chain_key.idx, sessionState.prev_counter, sessionState.send_chain.ratchet_key.public_key, msgkeys.encrypt(plaintext));
        if (pending) {
            message = new PreKeyMessage_1.PreKeyMessage(pending[0], pending[1], identityKey, message);
        }
        const envelope = new Envelope_1.Envelope(msgkeys.mac_key, message);
        sessionState.send_chain.chain_key = ChainKey_1.ChainKey.next(sessionState.send_chain.chain_key);
        return envelope;
    }
    decrypt(envelope, msg) {
        let idx = this.recv_chains.findIndex(chain => chain.ratchet_key.fingerprint() === msg.ratchet_key.fingerprint());
        if (idx === -1) {
            this.ratchet(msg.ratchet_key);
            idx = 0;
        }
        const receiveChain = this.recv_chains[idx];
        if (msg.counter < receiveChain.chain_key.idx) {
            return receiveChain.try_message_keys(envelope, msg);
        }
        else if (msg.counter == receiveChain.chain_key.idx) {
            const mks = ChainKey_1.ChainKey.message_keys(receiveChain.chain_key);
            if (!envelope.verify(mks.mac_key)) {
                throw new DecryptError_1.DecryptError.InvalidSignature(`Envelope verification failed for message with counters in sync at '${msg.counter}'. The received message was possibly encrypted for another client.`, DecryptError_1.DecryptError.CODE.CASE_206);
            }
            const plain = mks.decrypt(msg.cipher_text);
            receiveChain.chain_key = ChainKey_1.ChainKey.next(receiveChain.chain_key);
            return plain;
        }
        const [chainKey, messageKey, messageKeys] = receiveChain.stage_message_keys(msg);
        if (!envelope.verify(messageKey.mac_key)) {
            throw new DecryptError_1.DecryptError.InvalidSignature(`Envelope verification failed for message with counter ahead. Message index is '${msg.counter}' while receive chain index is '${receiveChain.chain_key.idx}'.`, DecryptError_1.DecryptError.CODE.CASE_207);
        }
        const plain = messageKey.decrypt(msg.cipher_text);
        receiveChain.chain_key = ChainKey_1.ChainKey.next(chainKey);
        receiveChain.commit_message_keys(messageKeys);
        return plain;
    }
    serialise() {
        const encoder = new cbor_1.Encoder();
        SessionState.encode(encoder, this);
        return encoder.get_buffer();
    }
    static deserialise(buf) {
        return SessionState.decode(new cbor_1.Decoder(buf));
    }
    static encode(encoder, sessionState) {
        encoder.object(SessionState.propertiesLength);
        encoder.u8(0);
        encoder.array(sessionState.recv_chains.length);
        sessionState.recv_chains.map(rch => RecvChain_1.RecvChain.encode(encoder, rch));
        encoder.u8(1);
        SendChain_1.SendChain.encode(encoder, sessionState.send_chain);
        encoder.u8(2);
        RootKey_1.RootKey.encode(encoder, sessionState.root_key);
        encoder.u8(3);
        return encoder.u32(sessionState.prev_counter);
    }
    static decode(decoder) {
        const propertiesLength = decoder.object();
        if (propertiesLength === SessionState.propertiesLength) {
            decoder.u8();
            const receiveChains = [];
            let len = decoder.array();
            while (len--) {
                receiveChains.push(RecvChain_1.RecvChain.decode(decoder));
            }
            decoder.u8();
            const sendChain = SendChain_1.SendChain.decode(decoder);
            decoder.u8();
            const rootKey = RootKey_1.RootKey.decode(decoder);
            decoder.u8();
            const prevCounter = decoder.u32();
            return new SessionState(rootKey, sendChain, receiveChains, prevCounter);
        }
        throw new DecodeError_1.DecodeError(`Unexpected number of properties: "${propertiesLength}"`);
    }
}
exports.SessionState = SessionState;
SessionState.MAX_RECV_CHAINS = 5;
SessionState.propertiesLength = 4;
//# sourceMappingURL=SessionState.js.map