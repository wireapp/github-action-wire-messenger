"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const path = require("path");
const worker_threads_1 = require("worker_threads");
const Session_1 = require("../session/Session");
const PreKeyBundle_1 = require("../keys/PreKeyBundle");
const IdentityKeyPair_1 = require("../keys/IdentityKeyPair");
const PreKey_1 = require("../keys/PreKey");
const initProteus_1 = require("../initProteus");
const program = require("commander");
const os = require("os");
program.option('--workers [amount]', 'amount of workers').parse();
function mapWorkers(workers) {
    switch (typeof workers) {
        case 'undefined':
            return 0;
        case 'boolean':
            return workers === true ? os.cpus().length : 0;
        case 'string':
            return parseInt(workers);
    }
}
const amountOfWorkers = mapWorkers(program.opts().workers);
function spawnWorker() {
    const { port1: fromWorker, port2: toWorker } = new worker_threads_1.MessageChannel();
    const worker = new worker_threads_1.Worker(path.resolve('src/worker.js'), {
        workerData: {
            workerPath: path.resolve(__dirname, 'InitSessionWorker.ts'),
        },
    });
    return {
        closeConnection: () => {
            fromWorker.close();
            toWorker.close();
        },
        initSessions: (data) => {
            return new Promise((resolve, reject) => {
                worker.postMessage({ port: toWorker, value: data }, [toWorker]);
                fromWorker.on('message', resolve);
                fromWorker.on('messageerror', reject);
            });
        },
    };
}
function chunkArray(array, size) {
    return Array.from({ length: Math.ceil(array.length / size) }, (_, index) => array.slice(index * size, index * size + size));
}
async function main() {
    await initProteus_1.initProteus();
    const amountOfUsers = 500;
    const clientsPerUser = 8;
    const amountOfRemoteIdentities = amountOfUsers * clientsPerUser;
    function generatePreKeyBundle() {
        const identity = new IdentityKeyPair_1.IdentityKeyPair();
        const preKey = PreKey_1.PreKey.last_resort();
        return new PreKeyBundle_1.PreKeyBundle(identity.public_key, preKey);
    }
    const observer = new perf_hooks_1.PerformanceObserver(items => items.getEntries().forEach(entry => console.info(entry)));
    observer.observe({ buffered: true, entryTypes: ['measure', 'function'] });
    perf_hooks_1.performance.mark('bundlesStart');
    const preKeyBundles = Array.from({ length: amountOfRemoteIdentities }, generatePreKeyBundle);
    perf_hooks_1.performance.mark('bundlesStop');
    perf_hooks_1.performance.measure(`Generating "${preKeyBundles.length}" pre-key bundles`, 'bundlesStart', 'bundlesStop');
    const ownIdentity = new IdentityKeyPair_1.IdentityKeyPair();
    perf_hooks_1.performance.mark('sessionsStart');
    let sessions = [];
    if (amountOfWorkers) {
        const bundlesPerThread = preKeyBundles.length / amountOfWorkers;
        const preKeyBundleChunks = chunkArray(preKeyBundles, bundlesPerThread);
        console.info(`Run test with "${amountOfWorkers}" worker threads.`);
        perf_hooks_1.performance.mark('workerPoolStart');
        const workers = Array.from({ length: amountOfWorkers }, () => spawnWorker());
        perf_hooks_1.performance.mark('workerPoolStop');
        perf_hooks_1.performance.measure(`Creating "${workers.length}" worker threads`, 'workerPoolStart', 'workerPoolStop');
        console.info(`Splitting "${preKeyBundles.length}" pre-key bundles into "${preKeyBundleChunks.length}" chunks with "${bundlesPerThread}" bundles each...`);
        for (let i = 0; i < preKeyBundleChunks.length; i++) {
            const preKeyBundles = preKeyBundleChunks[i];
            const sessionChunks = await workers[i].initSessions({
                ownIdentity,
                preKeyBundles,
            });
            sessions.push(...sessionChunks);
            workers[i].closeConnection();
        }
    }
    else {
        sessions = preKeyBundles.map(pkb => Session_1.Session.init_from_prekey(ownIdentity, pkb));
    }
    perf_hooks_1.performance.mark('sessionsStop');
    perf_hooks_1.performance.measure(`Initializing "${sessions.length}" sessions`, 'sessionsStart', 'sessionsStop');
    perf_hooks_1.performance.mark('encryptStart');
    const envelopes = sessions.map(session => Session_1.Session.encrypt(session, 'Hello, World!'));
    perf_hooks_1.performance.mark('encryptStop');
    perf_hooks_1.performance.measure(`Encrypting "${envelopes.length}" texts`, 'encryptStart', 'encryptStop');
}
main().catch(console.error);
//# sourceMappingURL=startBenchmark.js.map