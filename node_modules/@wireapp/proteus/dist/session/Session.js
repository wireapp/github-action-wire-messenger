"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = void 0;
const CBOR = require("@wireapp/cbor");
const MemoryUtil = require("../util/MemoryUtil");
const DecodeError_1 = require("../errors/DecodeError");
const DecryptError_1 = require("../errors/DecryptError");
const ProteusError_1 = require("../errors/ProteusError");
const SessionState_1 = require("./SessionState");
const IdentityKey_1 = require("../keys/IdentityKey");
const KeyPair_1 = require("../keys/KeyPair");
const PreKey_1 = require("../keys/PreKey");
const PublicKey_1 = require("../keys/PublicKey");
const CipherMessage_1 = require("../message/CipherMessage");
const PreKeyMessage_1 = require("../message/PreKeyMessage");
const SessionTag_1 = require("../message/SessionTag");
let Session = /** @class */ (() => {
    class Session {
        constructor(localIdentity, remoteIdentity, sessionTag = new SessionTag_1.SessionTag(), pendingPrekey = null, sessionStates = {}, version = 1) {
            this.local_identity = localIdentity;
            this.pending_prekey = pendingPrekey;
            this.remote_identity = remoteIdentity;
            this.session_states = sessionStates;
            this.session_tag = sessionTag;
            this.version = version;
            this.counter = 0;
        }
        /**
         * @param local_identity Alice's Identity Key Pair
         * @param remote_pkbundle Bob's Pre-Key Bundle
         */
        static init_from_prekey(local_identity, remote_pkbundle) {
            return __awaiter(this, void 0, void 0, function* () {
                const alice_base = yield KeyPair_1.KeyPair.new();
                const state = yield SessionState_1.SessionState.init_as_alice(local_identity, alice_base, remote_pkbundle);
                const session_tag = new SessionTag_1.SessionTag();
                const pendingPrekey = [remote_pkbundle.prekey_id, alice_base.public_key];
                const session = new Session(local_identity, remote_pkbundle.identity_key, session_tag, pendingPrekey);
                session._insert_session_state(session_tag, state);
                return session;
            });
        }
        static init_from_message(ourIdentity, prekey_store, envelope) {
            return __awaiter(this, void 0, void 0, function* () {
                const preKeyMessage = envelope.message;
                if (preKeyMessage instanceof CipherMessage_1.CipherMessage) {
                    throw new DecryptError_1.DecryptError.InvalidMessage("Can't initialise a session from a CipherMessage.", DecryptError_1.DecryptError.CODE.CASE_201);
                }
                if (preKeyMessage instanceof PreKeyMessage_1.PreKeyMessage) {
                    const session = new Session(ourIdentity, preKeyMessage.identity_key, preKeyMessage.message.session_tag);
                    const state = yield session._new_state(prekey_store, preKeyMessage);
                    const plain = yield state.decrypt(envelope, preKeyMessage.message);
                    session._insert_session_state(preKeyMessage.message.session_tag, state);
                    if (preKeyMessage.prekey_id < PreKey_1.PreKey.MAX_PREKEY_ID) {
                        const prekey = yield prekey_store.load_prekey(preKeyMessage.prekey_id);
                        MemoryUtil.zeroize(prekey);
                        try {
                            yield prekey_store.delete_prekey(preKeyMessage.prekey_id);
                        }
                        catch (error) {
                            throw new DecryptError_1.DecryptError.PrekeyNotFound(`Could not delete PreKey: ${error.message}`, DecryptError_1.DecryptError.CODE.CASE_203);
                        }
                    }
                    return [session, plain];
                }
                throw new DecryptError_1.DecryptError.InvalidMessage('Unknown message format: The message is neither a "CipherMessage" nor a "PreKeyMessage".', DecryptError_1.DecryptError.CODE.CASE_202);
            });
        }
        _new_state(preKeyStore, preKeyMessage) {
            return __awaiter(this, void 0, void 0, function* () {
                const pre_key = yield preKeyStore.load_prekey(preKeyMessage.prekey_id);
                if (pre_key) {
                    return SessionState_1.SessionState.init_as_bob(this.local_identity, pre_key.key_pair, preKeyMessage.identity_key, preKeyMessage.base_key);
                }
                throw new ProteusError_1.ProteusError(`Unable to find PreKey with ID "${preKeyMessage.prekey_id}" in PreKey store "${preKeyStore.constructor.name}".`, ProteusError_1.ProteusError.CODE.CASE_101);
            });
        }
        _insert_session_state(sessionTag, state) {
            if (this.session_states.hasOwnProperty(sessionTag.toString())) {
                this.session_states[sessionTag.toString()].state = state;
            }
            else {
                if (this.counter >= Number.MAX_SAFE_INTEGER) {
                    this.session_states = {};
                    this.counter = 0;
                }
                this.session_states[sessionTag.toString()] = {
                    idx: this.counter,
                    state,
                    tag: sessionTag,
                };
                this.counter++;
            }
            if (this.session_tag.toString() !== sessionTag.toString()) {
                this.session_tag = sessionTag;
            }
            const obj_size = (obj) => Object.keys(obj).length;
            if (obj_size(this.session_states) < Session.MAX_SESSION_STATES) {
                return;
            }
            // if we get here, it means that we have more than MAX_SESSION_STATES and
            // we need to evict the oldest one.
            return this._evict_oldest_session_state();
        }
        _evict_oldest_session_state() {
            const oldest = Object.keys(this.session_states)
                .filter(obj => obj.toString() !== this.session_tag.toString())
                .reduce((lowest, obj) => {
                return this.session_states[obj].idx < this.session_states[lowest].idx ? obj.toString() : lowest;
            });
            MemoryUtil.zeroize(this.session_states[oldest]);
            delete this.session_states[oldest];
        }
        get_local_identity() {
            return this.local_identity.public_key;
        }
        /**
         * @param plaintext The plaintext which needs to be encrypted
         */
        encrypt(plaintext) {
            return __awaiter(this, void 0, void 0, function* () {
                const session_state = this.session_states[this.session_tag.toString()];
                if (!session_state) {
                    throw new ProteusError_1.ProteusError(`Could not find session for tag '${(this.session_tag || '').toString()}'.`, ProteusError_1.ProteusError.CODE.CASE_102);
                }
                return session_state.state.encrypt(this.local_identity.public_key, this.pending_prekey, this.session_tag, plaintext);
            });
        }
        decrypt(prekey_store, envelope) {
            return __awaiter(this, void 0, void 0, function* () {
                const preKeyMessage = envelope.message;
                if (preKeyMessage instanceof CipherMessage_1.CipherMessage) {
                    return this._decrypt_cipher_message(envelope, preKeyMessage);
                }
                if (preKeyMessage instanceof PreKeyMessage_1.PreKeyMessage) {
                    const actual_fingerprint = preKeyMessage.identity_key.fingerprint();
                    const expected_fingerprint = this.remote_identity.fingerprint();
                    if (actual_fingerprint !== expected_fingerprint) {
                        const message = `Fingerprints do not match: We expected '${expected_fingerprint}', but received '${actual_fingerprint}'.`;
                        throw new DecryptError_1.DecryptError.RemoteIdentityChanged(message, DecryptError_1.DecryptError.CODE.CASE_204);
                    }
                    return this._decrypt_prekey_message(envelope, preKeyMessage, prekey_store);
                }
                throw new DecryptError_1.DecryptError('Unknown message type.', DecryptError_1.DecryptError.CODE.CASE_200);
            });
        }
        _decrypt_prekey_message(envelope, msg, prekey_store) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const plaintext = yield this._decrypt_cipher_message(envelope, msg.message);
                    return plaintext;
                }
                catch (error) {
                    if (error instanceof DecryptError_1.DecryptError.InvalidSignature || error instanceof DecryptError_1.DecryptError.InvalidMessage) {
                        const state = yield this._new_state(prekey_store, msg);
                        const plaintext = yield state.decrypt(envelope, msg.message);
                        if (msg.prekey_id !== PreKey_1.PreKey.MAX_PREKEY_ID) {
                            const prekey = yield prekey_store.load_prekey(msg.prekey_id);
                            MemoryUtil.zeroize(prekey);
                            yield prekey_store.delete_prekey(msg.prekey_id);
                        }
                        this._insert_session_state(msg.message.session_tag, state);
                        this.pending_prekey = null;
                        return plaintext;
                    }
                    throw error;
                }
            });
        }
        _decrypt_cipher_message(envelope, msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const state = this.session_states[msg.session_tag.toString()];
                if (!state) {
                    throw new DecryptError_1.DecryptError.InvalidMessage(`Local session not found for message session tag '${msg.session_tag}'.`, DecryptError_1.DecryptError.CODE.CASE_205);
                }
                // serialise and de-serialise for a deep clone
                // THIS IS IMPORTANT, DO NOT MUTATE THE SESSION STATE IN-PLACE
                // mutating in-place can lead to undefined behavior and undefined state in edge cases
                const sessionState = SessionState_1.SessionState.deserialise(state.state.serialise());
                const plaintext = yield sessionState.decrypt(envelope, msg);
                this.pending_prekey = null;
                this._insert_session_state(msg.session_tag, sessionState);
                return plaintext;
            });
        }
        serialise() {
            const encoder = new CBOR.Encoder();
            this.encode(encoder);
            return encoder.get_buffer();
        }
        static deserialise(local_identity, buf) {
            const decoder = new CBOR.Decoder(buf);
            return this.decode(local_identity, decoder);
        }
        encode(encoder) {
            encoder.object(6);
            encoder.u8(0);
            encoder.u8(this.version);
            encoder.u8(1);
            this.session_tag.encode(encoder);
            encoder.u8(2);
            this.local_identity.public_key.encode(encoder);
            encoder.u8(3);
            this.remote_identity.encode(encoder);
            encoder.u8(4);
            if (this.pending_prekey) {
                encoder.object(2);
                encoder.u8(0);
                encoder.u16(this.pending_prekey[0]);
                encoder.u8(1);
                this.pending_prekey[1].encode(encoder);
            }
            else {
                encoder.null();
            }
            encoder.u8(5);
            encoder.object(Object.keys(this.session_states).length);
            for (const index in this.session_states) {
                const state = this.session_states[index];
                state.tag.encode(encoder);
                state.state.encode(encoder);
            }
        }
        static decode(localIdentity, decoder) {
            let version;
            let sessionTag;
            let remoteIdentity;
            let pendingPrekey;
            let sessionStates = {};
            const propertiesLength = decoder.object();
            for (let index = 0; index <= propertiesLength - 1; index++) {
                switch (decoder.u8()) {
                    case 0: {
                        version = decoder.u8();
                        break;
                    }
                    case 1: {
                        sessionTag = SessionTag_1.SessionTag.decode(decoder);
                        break;
                    }
                    case 2: {
                        const identity_key = IdentityKey_1.IdentityKey.decode(decoder);
                        if (localIdentity.public_key.fingerprint() !== identity_key.fingerprint()) {
                            throw new DecodeError_1.DecodeError.LocalIdentityChanged(undefined, DecodeError_1.DecodeError.CODE.CASE_300);
                        }
                        localIdentity = localIdentity;
                        break;
                    }
                    case 3: {
                        remoteIdentity = IdentityKey_1.IdentityKey.decode(decoder);
                        break;
                    }
                    case 4: {
                        switch (decoder.optional(() => decoder.object())) {
                            case null:
                                pendingPrekey = null;
                                break;
                            case 2:
                                pendingPrekey = [];
                                for (let key = 0; key <= 1; ++key) {
                                    switch (decoder.u8()) {
                                        case 0:
                                            pendingPrekey[0] = decoder.u16();
                                            break;
                                        case 1:
                                            pendingPrekey[1] = PublicKey_1.PublicKey.decode(decoder);
                                            break;
                                    }
                                }
                                break;
                            default:
                                throw new DecodeError_1.DecodeError.InvalidType(undefined, DecodeError_1.DecodeError.CODE.CASE_301);
                        }
                        break;
                    }
                    case 5: {
                        sessionStates = {};
                        const nprops = decoder.object();
                        for (let index = 0; index <= nprops - 1; index++) {
                            const tag = SessionTag_1.SessionTag.decode(decoder);
                            sessionStates[tag.toString()] = {
                                idx: index,
                                state: SessionState_1.SessionState.decode(decoder),
                                tag,
                            };
                        }
                        break;
                    }
                    default: {
                        decoder.skip();
                    }
                }
            }
            if (!remoteIdentity) {
                throw new DecodeError_1.DecodeError('Missing remote identity');
            }
            return new Session(localIdentity, remoteIdentity, sessionTag, pendingPrekey, sessionStates, version);
        }
    }
    Session.MAX_RECV_CHAINS = 5;
    Session.MAX_SESSION_STATES = 100;
    return Session;
})();
exports.Session = Session;
//# sourceMappingURL=Session.js.map