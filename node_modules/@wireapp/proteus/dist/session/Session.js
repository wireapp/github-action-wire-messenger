"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const CBOR = require("@wireapp/cbor");
const ClassUtil = require("../util/ClassUtil");
const MemoryUtil = require("../util/MemoryUtil");
const DecodeError_1 = require("../errors/DecodeError");
const DecryptError_1 = require("../errors/DecryptError");
const ProteusError_1 = require("../errors/ProteusError");
const SessionState_1 = require("./SessionState");
const IdentityKey_1 = require("../keys/IdentityKey");
const IdentityKeyPair_1 = require("../keys/IdentityKeyPair");
const KeyPair_1 = require("../keys/KeyPair");
const PreKey_1 = require("../keys/PreKey");
const PublicKey_1 = require("../keys/PublicKey");
const CipherMessage_1 = require("../message/CipherMessage");
const PreKeyMessage_1 = require("../message/PreKeyMessage");
const SessionTag_1 = require("../message/SessionTag");
class Session {
    constructor() {
        this.counter = 0;
        this.version = 1;
        this.local_identity = new IdentityKeyPair_1.IdentityKeyPair();
        this.pending_prekey = null;
        this.remote_identity = new IdentityKey_1.IdentityKey();
        this.session_states = {};
        this.session_tag = new SessionTag_1.SessionTag();
    }
    /**
     * @param local_identity Alice's Identity Key Pair
     * @param remote_pkbundle Bob's Pre-Key Bundle
     */
    static init_from_prekey(local_identity, remote_pkbundle) {
        return __awaiter(this, void 0, void 0, function* () {
            const alice_base = yield KeyPair_1.KeyPair.new();
            const state = yield SessionState_1.SessionState.init_as_alice(local_identity, alice_base, remote_pkbundle);
            const session_tag = SessionTag_1.SessionTag.new();
            const session = ClassUtil.new_instance(this);
            session.session_tag = session_tag;
            session.local_identity = local_identity;
            session.remote_identity = remote_pkbundle.identity_key;
            session.pending_prekey = [remote_pkbundle.prekey_id, alice_base.public_key];
            session.session_states = {};
            session._insert_session_state(session_tag, state);
            return session;
        });
    }
    static init_from_message(our_identity, prekey_store, envelope) {
        return __awaiter(this, void 0, void 0, function* () {
            const preKeyMessage = envelope.message;
            if (preKeyMessage instanceof CipherMessage_1.CipherMessage) {
                throw new DecryptError_1.DecryptError.InvalidMessage("Can't initialise a session from a CipherMessage.", DecryptError_1.DecryptError.CODE.CASE_201);
            }
            if (preKeyMessage instanceof PreKeyMessage_1.PreKeyMessage) {
                const session = ClassUtil.new_instance(Session);
                session.session_tag = preKeyMessage.message.session_tag;
                session.local_identity = our_identity;
                session.remote_identity = preKeyMessage.identity_key;
                session.pending_prekey = null;
                session.session_states = {};
                const state = yield session._new_state(prekey_store, preKeyMessage);
                const plain = yield state.decrypt(envelope, preKeyMessage.message);
                session._insert_session_state(preKeyMessage.message.session_tag, state);
                if (preKeyMessage.prekey_id < PreKey_1.PreKey.MAX_PREKEY_ID) {
                    MemoryUtil.zeroize(yield prekey_store.load_prekey(preKeyMessage.prekey_id));
                    try {
                        yield prekey_store.delete_prekey(preKeyMessage.prekey_id);
                    }
                    catch (error) {
                        throw new DecryptError_1.DecryptError.PrekeyNotFound(`Could not delete PreKey: ${error.message}`, DecryptError_1.DecryptError.CODE.CASE_203);
                    }
                }
                return [session, plain];
            }
            throw new DecryptError_1.DecryptError.InvalidMessage('Unknown message format: The message is neither a "CipherMessage" nor a "PreKeyMessage".', DecryptError_1.DecryptError.CODE.CASE_202);
        });
    }
    _new_state(pre_key_store, pre_key_message) {
        return __awaiter(this, void 0, void 0, function* () {
            const pre_key = yield pre_key_store.load_prekey(pre_key_message.prekey_id);
            if (pre_key) {
                return SessionState_1.SessionState.init_as_bob(this.local_identity, pre_key.key_pair, pre_key_message.identity_key, pre_key_message.base_key);
            }
            throw new ProteusError_1.ProteusError(`Unable to find PreKey ID "${pre_key_message.prekey_id}" in PreKey store "${pre_key_store.constructor.name}".`, ProteusError_1.ProteusError.CODE.CASE_101);
        });
    }
    _insert_session_state(tag, state) {
        if (this.session_states.hasOwnProperty(tag.toString())) {
            this.session_states[tag.toString()].state = state;
        }
        else {
            if (this.counter >= Number.MAX_SAFE_INTEGER) {
                this.session_states = {};
                this.counter = 0;
            }
            this.session_states[tag.toString()] = {
                idx: this.counter,
                state: state,
                tag,
            };
            this.counter++;
        }
        if (this.session_tag.toString() !== tag.toString()) {
            this.session_tag = tag;
        }
        const obj_size = (obj) => Object.keys(obj).length;
        if (obj_size(this.session_states) < Session.MAX_SESSION_STATES) {
            return;
        }
        // if we get here, it means that we have more than MAX_SESSION_STATES and
        // we need to evict the oldest one.
        return this._evict_oldest_session_state();
    }
    _evict_oldest_session_state() {
        const oldest = Object.keys(this.session_states)
            .filter(obj => obj.toString() !== this.session_tag.toString())
            .reduce((lowest, obj, index) => {
            return this.session_states[obj].idx < this.session_states[lowest].idx ? obj.toString() : lowest;
        });
        MemoryUtil.zeroize(this.session_states[oldest]);
        delete this.session_states[oldest];
    }
    get_local_identity() {
        return this.local_identity.public_key;
    }
    /**
     * @param plaintext The plaintext which needs to be encrypted
     */
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const session_state = this.session_states[this.session_tag.toString()];
            if (!session_state) {
                throw new ProteusError_1.ProteusError(`Could not find session for tag '${(this.session_tag || '').toString()}'.`, ProteusError_1.ProteusError.CODE.CASE_102);
            }
            return session_state.state.encrypt(this.local_identity.public_key, this.pending_prekey, this.session_tag, plaintext);
        });
    }
    decrypt(prekey_store, envelope) {
        return __awaiter(this, void 0, void 0, function* () {
            const preKeyMessage = envelope.message;
            if (preKeyMessage instanceof CipherMessage_1.CipherMessage) {
                return this._decrypt_cipher_message(envelope, preKeyMessage);
            }
            if (preKeyMessage instanceof PreKeyMessage_1.PreKeyMessage) {
                const actual_fingerprint = preKeyMessage.identity_key.fingerprint();
                const expected_fingerprint = this.remote_identity.fingerprint();
                if (actual_fingerprint !== expected_fingerprint) {
                    const message = `Fingerprints do not match: We expected '${expected_fingerprint}', but received '${actual_fingerprint}'.`;
                    throw new DecryptError_1.DecryptError.RemoteIdentityChanged(message, DecryptError_1.DecryptError.CODE.CASE_204);
                }
                return this._decrypt_prekey_message(envelope, preKeyMessage, prekey_store);
            }
            throw new DecryptError_1.DecryptError('Unknown message type.', DecryptError_1.DecryptError.CODE.CASE_200);
        });
    }
    _decrypt_prekey_message(envelope, msg, prekey_store) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const plaintext = yield this._decrypt_cipher_message(envelope, msg.message);
                return plaintext;
            }
            catch (error) {
                if (error instanceof DecryptError_1.DecryptError.InvalidSignature || error instanceof DecryptError_1.DecryptError.InvalidMessage) {
                    const state = yield this._new_state(prekey_store, msg);
                    const plaintext = yield state.decrypt(envelope, msg.message);
                    if (msg.prekey_id !== PreKey_1.PreKey.MAX_PREKEY_ID) {
                        // TODO: Zeroize should be tested (and awaited) here!
                        MemoryUtil.zeroize(yield prekey_store.load_prekey(msg.prekey_id));
                        yield prekey_store.delete_prekey(msg.prekey_id);
                    }
                    this._insert_session_state(msg.message.session_tag, state);
                    this.pending_prekey = null;
                    return plaintext;
                }
                throw error;
            }
        });
    }
    _decrypt_cipher_message(envelope, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.session_states[msg.session_tag.toString()];
            if (!state) {
                throw new DecryptError_1.DecryptError.InvalidMessage(`Local session not found for message session tag '${msg.session_tag}'.`, DecryptError_1.DecryptError.CODE.CASE_205);
            }
            // serialise and de-serialise for a deep clone
            // THIS IS IMPORTANT, DO NOT MUTATE THE SESSION STATE IN-PLACE
            // mutating in-place can lead to undefined behavior and undefined state in edge cases
            const session_state = SessionState_1.SessionState.deserialise(state.state.serialise());
            const plaintext = yield session_state.decrypt(envelope, msg);
            this.pending_prekey = null;
            this._insert_session_state(msg.session_tag, session_state);
            return plaintext;
        });
    }
    serialise() {
        const encoder = new CBOR.Encoder();
        this.encode(encoder);
        return encoder.get_buffer();
    }
    static deserialise(local_identity, buf) {
        const decoder = new CBOR.Decoder(buf);
        return this.decode(local_identity, decoder);
    }
    encode(encoder) {
        encoder.object(6);
        encoder.u8(0);
        encoder.u8(this.version);
        encoder.u8(1);
        this.session_tag.encode(encoder);
        encoder.u8(2);
        this.local_identity.public_key.encode(encoder);
        encoder.u8(3);
        this.remote_identity.encode(encoder);
        encoder.u8(4);
        if (this.pending_prekey) {
            encoder.object(2);
            encoder.u8(0);
            encoder.u16(this.pending_prekey[0]);
            encoder.u8(1);
            this.pending_prekey[1].encode(encoder);
        }
        else {
            encoder.null();
        }
        encoder.u8(5);
        encoder.object(Object.keys(this.session_states).length);
        for (const index in this.session_states) {
            const state = this.session_states[index];
            state.tag.encode(encoder);
            state.state.encode(encoder);
        }
    }
    static decode(local_identity, decoder) {
        const self = ClassUtil.new_instance(this);
        const nprops = decoder.object();
        for (let index = 0; index <= nprops - 1; index++) {
            switch (decoder.u8()) {
                case 0: {
                    self.version = decoder.u8();
                    break;
                }
                case 1: {
                    self.session_tag = SessionTag_1.SessionTag.decode(decoder);
                    break;
                }
                case 2: {
                    const identity_key = IdentityKey_1.IdentityKey.decode(decoder);
                    if (local_identity.public_key.fingerprint() !== identity_key.fingerprint()) {
                        throw new DecodeError_1.DecodeError.LocalIdentityChanged(undefined, DecodeError_1.DecodeError.CODE.CASE_300);
                    }
                    self.local_identity = local_identity;
                    break;
                }
                case 3: {
                    self.remote_identity = IdentityKey_1.IdentityKey.decode(decoder);
                    break;
                }
                case 4: {
                    switch (decoder.optional(() => decoder.object())) {
                        case null:
                            self.pending_prekey = null;
                            break;
                        case 2:
                            self.pending_prekey = [];
                            for (let key = 0; key <= 1; ++key) {
                                switch (decoder.u8()) {
                                    case 0:
                                        self.pending_prekey[0] = decoder.u16();
                                        break;
                                    case 1:
                                        self.pending_prekey[1] = PublicKey_1.PublicKey.decode(decoder);
                                        break;
                                }
                            }
                            break;
                        default:
                            throw new DecodeError_1.DecodeError.InvalidType(undefined, DecodeError_1.DecodeError.CODE.CASE_301);
                    }
                    break;
                }
                case 5: {
                    self.session_states = {};
                    const nprops = decoder.object();
                    for (let index = 0; index <= nprops - 1; index++) {
                        const tag = SessionTag_1.SessionTag.decode(decoder);
                        self.session_states[tag.toString()] = {
                            idx: index,
                            state: SessionState_1.SessionState.decode(decoder),
                            tag,
                        };
                    }
                    break;
                }
                default: {
                    decoder.skip();
                }
            }
        }
        return self;
    }
}
exports.Session = Session;
Session.MAX_RECV_CHAINS = 5;
Session.MAX_SESSION_STATES = 100;
//# sourceMappingURL=Session.js.map