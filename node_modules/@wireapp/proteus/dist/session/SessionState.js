"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionState = void 0;
const CBOR = require("@wireapp/cbor");
const ArrayUtil = require("../util/ArrayUtil");
const MemoryUtil = require("../util/MemoryUtil");
const DecryptError_1 = require("../errors/DecryptError");
const DerivedSecrets_1 = require("../derived/DerivedSecrets");
const KeyPair_1 = require("../keys/KeyPair");
const CipherMessage_1 = require("../message/CipherMessage");
const Envelope_1 = require("../message/Envelope");
const PreKeyMessage_1 = require("../message/PreKeyMessage");
const ChainKey_1 = require("./ChainKey");
const RecvChain_1 = require("./RecvChain");
const RootKey_1 = require("./RootKey");
const SendChain_1 = require("./SendChain");
const Session_1 = require("./Session");
const errors_1 = require("../errors");
let SessionState = /** @class */ (() => {
    class SessionState {
        constructor(rootKey, sendChain, receiveChains = [], prevCounter = -1) {
            this.prev_counter = prevCounter;
            this.recv_chains = receiveChains;
            this.root_key = rootKey;
            this.send_chain = sendChain;
        }
        static init_as_alice(aliceIdentityPair, aliceBase, bobPreKeyBundle) {
            return __awaiter(this, void 0, void 0, function* () {
                const masterKey = ArrayUtil.concatenate_array_buffers([
                    aliceIdentityPair.secret_key.shared_secret(bobPreKeyBundle.public_key),
                    aliceBase.secret_key.shared_secret(bobPreKeyBundle.identity_key.public_key),
                    aliceBase.secret_key.shared_secret(bobPreKeyBundle.public_key),
                ]);
                const derivedSecrets = DerivedSecrets_1.DerivedSecrets.kdf_without_salt(masterKey, 'handshake');
                MemoryUtil.zeroize(masterKey);
                const rootkey = RootKey_1.RootKey.from_cipher_key(derivedSecrets.cipher_key);
                const chainkey = ChainKey_1.ChainKey.from_mac_key(derivedSecrets.mac_key, 0);
                const receiveChains = [new RecvChain_1.RecvChain(chainkey, bobPreKeyBundle.public_key)];
                const sendRatchet = yield KeyPair_1.KeyPair.new();
                const [rootKey, chk] = rootkey.dh_ratchet(sendRatchet, bobPreKeyBundle.public_key);
                const sendChain = new SendChain_1.SendChain(chk, sendRatchet);
                return new SessionState(rootKey, sendChain, receiveChains, 0);
            });
        }
        static init_as_bob(bobIdent, bobPrekey, aliceIdent, aliceBase) {
            const masterKey = ArrayUtil.concatenate_array_buffers([
                bobPrekey.secret_key.shared_secret(aliceIdent.public_key),
                bobIdent.secret_key.shared_secret(aliceBase),
                bobPrekey.secret_key.shared_secret(aliceBase),
            ]);
            const derivedSecrets = DerivedSecrets_1.DerivedSecrets.kdf_without_salt(masterKey, 'handshake');
            MemoryUtil.zeroize(masterKey);
            const rootkey = RootKey_1.RootKey.from_cipher_key(derivedSecrets.cipher_key);
            const chainkey = ChainKey_1.ChainKey.from_mac_key(derivedSecrets.mac_key, 0);
            const sendChain = new SendChain_1.SendChain(chainkey, bobPrekey);
            return new SessionState(rootkey, sendChain, [], 0);
        }
        ratchet(ratchetKey) {
            return __awaiter(this, void 0, void 0, function* () {
                const newRatchet = yield KeyPair_1.KeyPair.new();
                const [receiveRootKey, receiveChainKey] = this.root_key.dh_ratchet(this.send_chain.ratchet_key, ratchetKey);
                const [sendRootKey, sendChainKey] = receiveRootKey.dh_ratchet(newRatchet, ratchetKey);
                const receiveChain = new RecvChain_1.RecvChain(receiveChainKey, ratchetKey);
                const sendChain = new SendChain_1.SendChain(sendChainKey, newRatchet);
                this.root_key = sendRootKey;
                this.prev_counter = this.send_chain.chain_key.idx;
                this.send_chain = sendChain;
                this.recv_chains.unshift(receiveChain);
                if (this.recv_chains.length > Session_1.Session.MAX_RECV_CHAINS) {
                    for (let index = Session_1.Session.MAX_RECV_CHAINS; index < this.recv_chains.length; index++) {
                        MemoryUtil.zeroize(this.recv_chains[index]);
                    }
                    this.recv_chains = this.recv_chains.slice(0, Session_1.Session.MAX_RECV_CHAINS);
                }
            });
        }
        /**
         * @param identityKey Public identity key of the local identity key pair
         * @param pending Pending pre-key
         * @param tag Session tag
         * @param plaintext The plaintext to encrypt
         */
        encrypt(identityKey, pending, tag, plaintext) {
            const msgkeys = this.send_chain.chain_key.message_keys();
            let message = new CipherMessage_1.CipherMessage(tag, this.send_chain.chain_key.idx, this.prev_counter, this.send_chain.ratchet_key.public_key, msgkeys.encrypt(plaintext));
            if (pending) {
                message = new PreKeyMessage_1.PreKeyMessage(pending[0], pending[1], identityKey, message);
            }
            const envelope = new Envelope_1.Envelope(msgkeys.mac_key, message);
            this.send_chain.chain_key = this.send_chain.chain_key.next();
            return envelope;
        }
        decrypt(envelope, msg) {
            return __awaiter(this, void 0, void 0, function* () {
                let idx = this.recv_chains.findIndex(chain => chain.ratchet_key.fingerprint() === msg.ratchet_key.fingerprint());
                if (idx === -1) {
                    yield this.ratchet(msg.ratchet_key);
                    idx = 0;
                }
                const receiveChain = this.recv_chains[idx];
                if (msg.counter < receiveChain.chain_key.idx) {
                    return receiveChain.try_message_keys(envelope, msg);
                }
                else if (msg.counter == receiveChain.chain_key.idx) {
                    const mks = receiveChain.chain_key.message_keys();
                    if (!envelope.verify(mks.mac_key)) {
                        throw new DecryptError_1.DecryptError.InvalidSignature(`Envelope verification failed for message with counters in sync at '${msg.counter}'. The received message was possibly encrypted for another client.`, DecryptError_1.DecryptError.CODE.CASE_206);
                    }
                    const plain = mks.decrypt(msg.cipher_text);
                    receiveChain.chain_key = receiveChain.chain_key.next();
                    return plain;
                }
                const [chainKey, messageKey, messageKeys] = receiveChain.stage_message_keys(msg);
                if (!envelope.verify(messageKey.mac_key)) {
                    throw new DecryptError_1.DecryptError.InvalidSignature(`Envelope verification failed for message with counter ahead. Message index is '${msg.counter}' while receive chain index is '${receiveChain.chain_key.idx}'.`, DecryptError_1.DecryptError.CODE.CASE_207);
                }
                const plain = messageKey.decrypt(msg.cipher_text);
                receiveChain.chain_key = chainKey.next();
                receiveChain.commit_message_keys(messageKeys);
                return plain;
            });
        }
        serialise() {
            const encoder = new CBOR.Encoder();
            this.encode(encoder);
            return encoder.get_buffer();
        }
        static deserialise(buf) {
            return SessionState.decode(new CBOR.Decoder(buf));
        }
        encode(encoder) {
            encoder.object(SessionState.propertiesLength);
            encoder.u8(0);
            encoder.array(this.recv_chains.length);
            this.recv_chains.map(rch => rch.encode(encoder));
            encoder.u8(1);
            this.send_chain.encode(encoder);
            encoder.u8(2);
            this.root_key.encode(encoder);
            encoder.u8(3);
            return encoder.u32(this.prev_counter);
        }
        static decode(decoder) {
            const propertiesLength = decoder.object();
            if (propertiesLength === SessionState.propertiesLength) {
                decoder.u8();
                const receiveChains = [];
                let len = decoder.array();
                while (len--) {
                    receiveChains.push(RecvChain_1.RecvChain.decode(decoder));
                }
                decoder.u8();
                const sendChain = SendChain_1.SendChain.decode(decoder);
                decoder.u8();
                const rootKey = RootKey_1.RootKey.decode(decoder);
                decoder.u8();
                const prevCounter = decoder.u32();
                return new SessionState(rootKey, sendChain, receiveChains, prevCounter);
            }
            throw new errors_1.DecodeError(`Unexpected number of properties: "${propertiesLength}"`);
        }
    }
    SessionState.propertiesLength = 4;
    return SessionState;
})();
exports.SessionState = SessionState;
//# sourceMappingURL=SessionState.js.map