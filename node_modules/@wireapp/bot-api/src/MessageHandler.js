"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageHandler = void 0;
const data_1 = require("@wireapp/api-client/src/conversation/data");
const protocol_messaging_1 = require("@wireapp/protocol-messaging");
const util_1 = require("util");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const FileType = require("file-type");
const conversation_1 = require("@wireapp/api-client/src/conversation");
class MessageHandler {
    constructor() {
        this.account = undefined;
    }
    async addUser(conversationId, userId) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            await this.account.service.conversation.addUser(conversationId, userId);
        }
    }
    async clearConversation(conversationId) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            await this.account.service.conversation.clearConversation(conversationId);
        }
    }
    getConversation(conversationId) {
        return this.account.service.conversation.getConversations(conversationId);
    }
    getConversations(conversationIds) {
        return this.account.service.conversation.getConversations(conversationIds);
    }
    async getUser(userId) {
        return this.account.service.user.getUser(userId);
    }
    async getUsers(userIds) {
        return this.account.service.user.getUsers(userIds);
    }
    async removeUser(conversationId, userId) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            await this.account.service.conversation.removeUser(conversationId, userId);
        }
    }
    async setAdminRole(conversationId, userId) {
        return this.account.service.conversation.setMemberConversationRole(conversationId, userId, conversation_1.DefaultConversationRoleName.WIRE_ADMIN);
    }
    async setMemberRole(conversationId, userId) {
        return this.account.service.conversation.setMemberConversationRole(conversationId, userId, conversation_1.DefaultConversationRoleName.WIRE_MEMBER);
    }
    async sendButtonActionConfirmation(conversationId, userId, referenceMessageId, buttonId) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const buttonActionConfirmationContent = {
                buttonId,
                referenceMessageId,
            };
            const buttonActionConfirmationMessage = this.account.service.conversation.messageBuilder.createButtonActionConfirmationMessage({
                conversationId,
                content: buttonActionConfirmationContent,
            });
            await this.account.service.conversation.send({ payloadBundle: buttonActionConfirmationMessage, userIds: [userId] });
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendCall(conversationId, content, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const callPayload = this.account.service.conversation.messageBuilder.createCall({ conversationId, content });
            await this.account.service.conversation.send({ payloadBundle: callPayload, userIds });
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendPoll(conversationId, text, buttons, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const message = this.account.service.conversation.messageBuilder
                .createComposite({ conversationId })
                .addText(protocol_messaging_1.Text.create({ content: text }));
            buttons.forEach(button => message.addButton(button));
            await this.account.service.conversation.send({ payloadBundle: message.build(), userIds });
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendConfirmation(conversationId, firstMessageId, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const confirmationPayload = this.account.service.conversation.messageBuilder.createConfirmation({
                conversationId,
                firstMessageId,
                type: protocol_messaging_1.Confirmation.Type.DELIVERED,
            });
            await this.account.service.conversation.send({ payloadBundle: confirmationPayload, userIds });
        }
    }
    async sendConnectionRequest(userId) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            await this.account.service.connection.createConnection(userId);
        }
    }
    async sendConnectionResponse(userId, accept) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            if (accept) {
                await this.account.service.connection.acceptConnection(userId);
            }
            else {
                await this.account.service.connection.ignoreConnection(userId);
            }
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendEditedText(conversationId, originalMessageId, newMessageText, newMentions, newLinkPreview, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const editedPayload = this.account.service.conversation.messageBuilder
                .createEditedText({ conversationId, newMessageText, originalMessageId })
                .withMentions(newMentions)
                .build();
            const editedMessage = await this.account.service.conversation.send({ payloadBundle: editedPayload, userIds });
            if (newLinkPreview) {
                const linkPreviewPayload = await this.account.service.conversation.messageBuilder.createLinkPreview(newLinkPreview);
                const editedWithPreviewPayload = this.account.service.conversation.messageBuilder
                    .createEditedText({ conversationId, newMessageText, originalMessageId, messageId: editedMessage.id })
                    .withLinkPreviews([linkPreviewPayload])
                    .withMentions(newMentions)
                    .build();
                await this.account.service.conversation.send({ payloadBundle: editedWithPreviewPayload, userIds });
            }
        }
    }
    async sendFileByPath(conversationId, filePath, userIds) {
        const data = await (0, util_1.promisify)(fs_1.default.readFile)(filePath);
        const fileType = await FileType.fromBuffer(data);
        const metadata = {
            length: data.length,
            name: path_1.default.basename(filePath),
            type: fileType ? fileType.mime : 'text/plain',
        };
        return this.sendFile(conversationId, {
            data,
        }, metadata, userIds);
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendFile(conversationId, file, metadata, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const metadataPayload = this.account.service.conversation.messageBuilder.createFileMetadata({
                conversationId,
                metaData: metadata,
            });
            await this.account.service.conversation.send({ payloadBundle: metadataPayload, userIds });
            try {
                const filePayload = await this.account.service.conversation.messageBuilder.createFileData({
                    conversationId,
                    file,
                    originalMessageId: metadataPayload.id,
                });
                await this.account.service.conversation.send({ payloadBundle: filePayload, userIds });
            }
            catch (error) {
                const abortPayload = await this.account.service.conversation.messageBuilder.createFileAbort({
                    conversationId,
                    reason: protocol_messaging_1.Asset.NotUploaded.FAILED,
                    originalMessageId: metadataPayload.id,
                });
                await this.account.service.conversation.send({ payloadBundle: abortPayload, userIds });
            }
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendImage(conversationId, image, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const imagePayload = await this.account.service.conversation.messageBuilder.createImage({ conversationId, image });
            await this.account.service.conversation.send({ payloadBundle: imagePayload, userIds });
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendLocation(conversationId, location, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const locationPayload = this.account.service.conversation.messageBuilder.createLocation({
                conversationId,
                location,
            });
            await this.account.service.conversation.send({ payloadBundle: locationPayload, userIds });
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendPing(conversationId, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const pingPayload = this.account.service.conversation.messageBuilder.createPing({ conversationId });
            await this.account.service.conversation.send({ payloadBundle: pingPayload, userIds });
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendReaction(conversationId, originalMessageId, type, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const reactionPayload = this.account.service.conversation.messageBuilder.createReaction({
                conversationId,
                reaction: {
                    originalMessageId,
                    type,
                },
            });
            await this.account.service.conversation.send({ payloadBundle: reactionPayload, userIds });
        }
    }
    async sendQuote(conversationId, quotedMessage, text, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const replyPayload = this.account.service.conversation.messageBuilder
                .createText({ conversationId, text })
                .withQuote(quotedMessage)
                .build();
            await this.account.service.conversation.send({ payloadBundle: replyPayload, userIds });
        }
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    sendReply(conversationId, quotedMessage, text, userIds) {
        return this.sendQuote(conversationId, quotedMessage, text, userIds);
    }
    /**
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     */
    async sendText(conversationId, text, mentions, linkPreview, userIds) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            const payload = this.account.service.conversation.messageBuilder
                .createText({ conversationId, text })
                .withMentions(mentions)
                .build();
            const sentMessage = await this.account.service.conversation.send({ payloadBundle: payload, userIds });
            if (linkPreview) {
                const linkPreviewPayload = await this.account.service.conversation.messageBuilder.createLinkPreview(linkPreview);
                const editedWithPreviewPayload = this.account.service.conversation.messageBuilder
                    .createText({ conversationId, text, messageId: sentMessage.id })
                    .withLinkPreviews([linkPreviewPayload])
                    .withMentions(mentions)
                    .build();
                await this.account.service.conversation.send({ payloadBundle: editedWithPreviewPayload, userIds });
            }
        }
    }
    async sendTyping(conversationId, status) {
        var _a;
        if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
            if (status === data_1.CONVERSATION_TYPING.STARTED) {
                await this.account.service.conversation.sendTypingStart(conversationId);
            }
            else {
                await this.account.service.conversation.sendTypingStop(conversationId);
            }
        }
    }
}
exports.MessageHandler = MessageHandler;
//# sourceMappingURL=MessageHandler.js.map