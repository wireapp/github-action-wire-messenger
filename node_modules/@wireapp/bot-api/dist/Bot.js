"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bot = void 0;
const api_client_1 = require("@wireapp/api-client");
const client_1 = require("@wireapp/api-client/dist/client/");
const core_1 = require("@wireapp/core");
const conversation_1 = require("@wireapp/core/dist/conversation/");
const logdown_1 = __importDefault(require("logdown"));
const uuidjs_1 = __importDefault(require("uuidjs"));
const conversation_2 = require("@wireapp/api-client/dist/conversation");
const auth_1 = require("@wireapp/api-client/dist/auth");
const defaultConfig = {
    backend: 'production',
    clientType: client_1.ClientType.TEMPORARY,
    conversations: [],
    owners: [],
};
class Bot {
    constructor(credentials, config) {
        this.credentials = credentials;
        this.config = Object.assign(Object.assign({}, defaultConfig), config);
        this.credentials = credentials;
        this.handlers = new Map();
        this.logger = logdown_1.default('@wireapp/bot-api/Bot', {
            logger: console,
            markdown: false,
        });
    }
    addHandler(handler) {
        this.handlers.set(uuidjs_1.default.genV4().toString(), handler);
    }
    removeHandler(key) {
        this.handlers.delete(key);
    }
    isAllowedConversation(conversationId) {
        return this.config.conversations.length === 0 ? true : this.config.conversations.includes(conversationId);
    }
    isOwner(userId) {
        return this.config.owners.length === 0 ? true : this.config.owners.includes(userId);
    }
    sendText(conversationId, message) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.account) === null || _a === void 0 ? void 0 : _a.service) {
                const textPayload = yield this.account.service.conversation.messageBuilder
                    .createText(conversationId, message)
                    .build();
                yield this.account.service.conversation.send(textPayload);
            }
        });
    }
    setAdminRole(conversationId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.account.service.conversation.setMemberConversationRole(conversationId, userId, conversation_2.DefaultConversationRoleName.WIRE_ADMIN);
        });
    }
    setMemberRole(conversationId, userId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.account.service.conversation.setMemberConversationRole(conversationId, userId, conversation_2.DefaultConversationRoleName.WIRE_MEMBER);
        });
    }
    start(storeEngine) {
        return __awaiter(this, void 0, void 0, function* () {
            const login = {
                clientType: this.config.clientType,
                email: this.credentials.email,
                password: this.credentials.password,
            };
            const apiClient = new api_client_1.APIClient({
                urls: this.config.backend === 'staging' ? api_client_1.APIClient.BACKEND.STAGING : api_client_1.APIClient.BACKEND.PRODUCTION,
            });
            apiClient.on(api_client_1.APIClient.TOPIC.ACCESS_TOKEN_REFRESH, (accessToken) => __awaiter(this, void 0, void 0, function* () {
                yield (storeEngine === null || storeEngine === void 0 ? void 0 : storeEngine.updateOrCreate(auth_1.AUTH_TABLE_NAME, auth_1.AUTH_ACCESS_TOKEN_KEY, accessToken));
            }));
            this.account = storeEngine ? new core_1.Account(apiClient, () => Promise.resolve(storeEngine)) : new core_1.Account(apiClient);
            for (const payloadType of Object.values(conversation_1.PayloadBundleType)) {
                this.account.removeAllListeners(payloadType);
                this.account.on(payloadType, this.handlePayload.bind(this));
            }
            try {
                if (!storeEngine) {
                    throw new Error('Store engine not provided');
                }
                const cookie = yield this.getCookie(storeEngine);
                yield this.account.init(this.config.clientType, cookie);
            }
            catch (error) {
                this.logger.warn('Failed to init account from cookie', error);
                yield this.account.login(login);
            }
            yield this.account.listen();
            this.handlers.forEach(handler => (handler.account = this.account));
            return apiClient;
        });
    }
    getCookie(storeEngine) {
        return __awaiter(this, void 0, void 0, function* () {
            const { expiration, zuid } = yield storeEngine.read(auth_1.AUTH_TABLE_NAME, auth_1.AUTH_COOKIE_KEY);
            const cookie = new auth_1.Cookie(zuid, expiration);
            return cookie;
        });
    }
    handlePayload(payload) {
        if ('conversation' in payload && this.validateMessage(payload.conversation, payload.from)) {
            this.handlers.forEach(handler => handler.handleEvent(payload));
        }
    }
    validateMessage(conversationID, userID) {
        if (!this.isAllowedConversation(conversationID)) {
            this.logger.info(`Skipping message because conversation "${conversationID}" is not in the list of allowed conversations.`);
        }
        if (!this.isOwner(userID)) {
            this.logger.info(`Skipping message because sender "${userID}" is not in the list of owners.`);
        }
        return this.isAllowedConversation(conversationID) && this.isOwner(userID);
    }
}
exports.Bot = Bot;
//# sourceMappingURL=Bot.js.map