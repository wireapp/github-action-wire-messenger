"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const logdown_1 = __importDefault(require("logdown"));
const AccountAPI_1 = require("./account/AccountAPI");
const asset_1 = require("./asset/");
const auth_1 = require("./auth/");
const CookieStore_1 = require("./auth/CookieStore");
const broadcast_1 = require("./broadcast/");
const client_1 = require("./client/");
const connection_1 = require("./connection/");
const conversation_1 = require("./conversation/");
const env_1 = require("./env/");
const giphy_1 = require("./giphy/");
const http_1 = require("./http/");
const notification_1 = require("./notification/");
const obfuscation_1 = require("./obfuscation/");
const self_1 = require("./self/");
const tcp_1 = require("./tcp/");
const team_1 = require("./team/");
const user_1 = require("./user/");
const { version } = require('../package.json');
var TOPIC;
(function (TOPIC) {
    TOPIC["ACCESS_TOKEN_REFRESH"] = "APIClient.TOPIC.ACCESS_TOKEN_REFRESH";
    TOPIC["COOKIE_REFRESH"] = "APIClient.TOPIC.COOKIE_REFRESH";
    TOPIC["ON_LOGOUT"] = "APIClient.TOPIC.ON_LOGOUT";
})(TOPIC || (TOPIC = {}));
const defaultConfig = {
    urls: env_1.Backend.PRODUCTION,
};
class APIClient extends events_1.default {
    constructor(config) {
        super();
        this.config = Object.assign(Object.assign({}, defaultConfig), config);
        this.accessTokenStore = new auth_1.AccessTokenStore();
        this.accessTokenStore.on(auth_1.AccessTokenStore.TOPIC.ACCESS_TOKEN_REFRESH, (accessToken) => this.emit(APIClient.TOPIC.ACCESS_TOKEN_REFRESH, accessToken));
        CookieStore_1.CookieStore.emitter.on(CookieStore_1.CookieStore.TOPIC.COOKIE_REFRESH, (cookie) => this.emit(APIClient.TOPIC.COOKIE_REFRESH, cookie));
        this.logger = logdown_1.default('@wireapp/api-client/Client', {
            logger: console,
            markdown: false,
        });
        const httpClient = new http_1.HttpClient(this.config.urls.rest, this.accessTokenStore);
        const webSocket = new tcp_1.WebSocketClient(this.config.urls.ws, httpClient);
        webSocket.on(tcp_1.WebSocketClient.TOPIC.ON_INVALID_TOKEN, (error) => __awaiter(this, void 0, void 0, function* () {
            this.logger.warn(`Cannot renew access token because cookie is invalid: ${error.message}`, error);
            yield this.logout();
            this.emit(APIClient.TOPIC.ON_LOGOUT, error);
        }));
        this.transport = {
            http: httpClient,
            ws: webSocket,
        };
        this.account = {
            api: new AccountAPI_1.AccountAPI(this.transport.http),
        };
        this.asset = {
            api: new asset_1.AssetAPI(this.transport.http),
        };
        this.auth = {
            api: new auth_1.AuthAPI(this.transport.http),
        };
        this.broadcast = {
            api: new broadcast_1.BroadcastAPI(this.transport.http),
        };
        this.client = {
            api: new client_1.ClientAPI(this.transport.http),
        };
        this.connection = {
            api: new connection_1.ConnectionAPI(this.transport.http),
        };
        this.conversation = {
            api: new conversation_1.ConversationAPI(this.transport.http),
        };
        this.giphy = {
            api: new giphy_1.GiphyAPI(this.transport.http),
        };
        this.notification = {
            api: new notification_1.NotificationAPI(this.transport.http),
        };
        this.self = {
            api: new self_1.SelfAPI(this.transport.http),
        };
        this.teams = {
            conversation: {
                api: new team_1.TeamConversationAPI(this.transport.http),
            },
            feature: {
                api: new team_1.FeatureAPI(this.transport.http),
            },
            identityProvider: {
                api: new team_1.IdentityProviderAPI(this.transport.http),
            },
            invitation: {
                api: new team_1.TeamInvitationAPI(this.transport.http),
            },
            legalhold: {
                api: new team_1.LegalHoldAPI(this.transport.http),
            },
            member: {
                api: new team_1.MemberAPI(this.transport.http),
            },
            payment: {
                api: new team_1.PaymentAPI(this.transport.http),
            },
            service: {
                api: new team_1.ServiceAPI(this.transport.http),
            },
            team: {
                api: new team_1.TeamAPI(this.transport.http),
            },
        };
        this.user = {
            api: new user_1.UserAPI(this.transport.http),
        };
    }
    init(clientType = client_1.ClientType.NONE, cookie) {
        return __awaiter(this, void 0, void 0, function* () {
            CookieStore_1.CookieStore.setCookie(cookie);
            const initialAccessToken = yield this.transport.http.refreshAccessToken();
            const context = this.createContext(initialAccessToken.user, clientType);
            yield this.accessTokenStore.updateToken(initialAccessToken);
            return context;
        });
    }
    login(loginData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.context) {
                yield this.logout({ ignoreError: true });
            }
            const accessToken = yield this.auth.api.postLogin(loginData);
            this.logger.info(`Saved initial access token. It will expire in "${accessToken.expires_in}" seconds.`, obfuscation_1.ObfuscationUtil.obfuscateAccessToken(accessToken));
            yield this.accessTokenStore.updateToken(accessToken);
            return this.createContext(accessToken.user, loginData.clientType);
        });
    }
    register(userAccount, clientType = client_1.ClientType.PERMANENT) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.context) {
                yield this.logout({ ignoreError: true });
            }
            const user = yield this.auth.api.postRegister(userAccount);
            yield this.createContext(user.id, clientType);
            return this.init(clientType, CookieStore_1.CookieStore.getCookie());
        });
    }
    logout(options = { ignoreError: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.disconnect('Closed by client logout');
                yield this.auth.api.postLogout();
            }
            catch (error) {
                if (options.ignoreError) {
                    this.logger.error(error);
                }
                else {
                    throw error;
                }
            }
            finally {
                CookieStore_1.CookieStore.deleteCookie();
            }
            yield this.accessTokenStore.delete();
            delete this.context;
        });
    }
    connect(onBeforeConnect) {
        var _a;
        return this.transport.ws.connect((_a = this.context) === null || _a === void 0 ? void 0 : _a.clientId, onBeforeConnect);
    }
    createContext(userId, clientType, clientId) {
        this.context = this.context ? Object.assign(Object.assign({}, this.context), { clientId, clientType }) : { clientId, clientType, userId };
        return this.context;
    }
    disconnect(reason) {
        this.transport.ws.disconnect(reason);
    }
    get clientId() {
        var _a;
        return ((_a = this.context) === null || _a === void 0 ? void 0 : _a.clientId) || undefined;
    }
    get userId() {
        var _a;
        return ((_a = this.context) === null || _a === void 0 ? void 0 : _a.userId) || undefined;
    }
    /** Should be used in cases where the user ID is MANDATORY. */
    get validatedUserId() {
        if (this.userId) {
            return this.userId;
        }
        throw new Error('No valid user ID.');
    }
    /** Should be used in cases where the client ID is MANDATORY. */
    get validatedClientId() {
        if (this.clientId) {
            return this.clientId;
        }
        throw new Error('No valid client ID.');
    }
}
exports.APIClient = APIClient;
APIClient.BACKEND = env_1.Backend;
APIClient.TOPIC = TOPIC;
APIClient.VERSION = version;
//# sourceMappingURL=APIClient.js.map