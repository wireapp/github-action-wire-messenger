"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.APIClient = void 0;
const events_1 = require("events");
const logdown_1 = __importDefault(require("logdown"));
const AccountAPI_1 = require("./account/AccountAPI");
const asset_1 = require("./asset/");
const auth_1 = require("./auth/");
const CookieStore_1 = require("./auth/CookieStore");
const broadcast_1 = require("./broadcast/");
const client_1 = require("./client/");
const connection_1 = require("./connection/");
const conversation_1 = require("./conversation/");
const env_1 = require("./env/");
const giphy_1 = require("./giphy/");
const http_1 = require("./http/");
const notification_1 = require("./notification/");
const obfuscation_1 = require("./obfuscation/");
const self_1 = require("./self/");
const tcp_1 = require("./tcp/");
const team_1 = require("./team/");
const user_1 = require("./user/");
const { version } = require('../package.json');
var TOPIC;
(function (TOPIC) {
    TOPIC["ACCESS_TOKEN_REFRESH"] = "APIClient.TOPIC.ACCESS_TOKEN_REFRESH";
    TOPIC["COOKIE_REFRESH"] = "APIClient.TOPIC.COOKIE_REFRESH";
    /** Event being sent when logout is done. */
    TOPIC["ON_LOGOUT"] = "APIClient.TOPIC.ON_LOGOUT";
})(TOPIC || (TOPIC = {}));
const defaultConfig = {
    urls: env_1.Backend.PRODUCTION,
};
let APIClient = /** @class */ (() => {
    class APIClient extends events_1.EventEmitter {
        constructor(config) {
            super();
            this.config = Object.assign(Object.assign({}, defaultConfig), config);
            this.accessTokenStore = new auth_1.AccessTokenStore();
            this.accessTokenStore.on(auth_1.AccessTokenStore.TOPIC.ACCESS_TOKEN_REFRESH, (accessToken) => this.emit(APIClient.TOPIC.ACCESS_TOKEN_REFRESH, accessToken));
            CookieStore_1.CookieStore.emitter.on(CookieStore_1.CookieStore.TOPIC.COOKIE_REFRESH, (cookie) => this.emit(APIClient.TOPIC.COOKIE_REFRESH, cookie));
            this.logger = logdown_1.default('@wireapp/api-client/Client', {
                logger: console,
                markdown: false,
            });
            const httpClient = new http_1.HttpClient(this.config.urls.rest, this.accessTokenStore);
            const webSocket = new tcp_1.WebSocketClient(this.config.urls.ws, httpClient);
            webSocket.on(tcp_1.WebSocketClient.TOPIC.ON_INVALID_TOKEN, (error) => __awaiter(this, void 0, void 0, function* () {
                this.logger.warn(`Cannot renew access token because cookie is invalid: ${error.message}`, error);
                yield this.logout();
                this.emit(APIClient.TOPIC.ON_LOGOUT, error);
            }));
            this.transport = {
                http: httpClient,
                ws: webSocket,
            };
            this.account = {
                api: new AccountAPI_1.AccountAPI(this.transport.http),
            };
            this.asset = {
                api: new asset_1.AssetAPI(this.transport.http),
            };
            this.auth = {
                api: new auth_1.AuthAPI(this.transport.http),
            };
            this.broadcast = {
                api: new broadcast_1.BroadcastAPI(this.transport.http),
            };
            this.client = {
                api: new client_1.ClientAPI(this.transport.http),
            };
            this.connection = {
                api: new connection_1.ConnectionAPI(this.transport.http),
            };
            this.conversation = {
                api: new conversation_1.ConversationAPI(this.transport.http),
            };
            this.giphy = {
                api: new giphy_1.GiphyAPI(this.transport.http),
            };
            this.notification = {
                api: new notification_1.NotificationAPI(this.transport.http),
            };
            this.self = {
                api: new self_1.SelfAPI(this.transport.http),
            };
            this.teams = {
                conversation: {
                    api: new team_1.TeamConversationAPI(this.transport.http),
                },
                feature: {
                    api: new team_1.FeatureAPI(this.transport.http),
                },
                identityProvider: {
                    api: new team_1.IdentityProviderAPI(this.transport.http),
                },
                invitation: {
                    api: new team_1.TeamInvitationAPI(this.transport.http),
                },
                legalhold: {
                    api: new team_1.LegalHoldAPI(this.transport.http),
                },
                member: {
                    api: new team_1.MemberAPI(this.transport.http),
                },
                payment: {
                    api: new team_1.PaymentAPI(this.transport.http),
                },
                property: {
                    api: new team_1.PropertyAPI(this.transport.http),
                },
                service: {
                    api: new team_1.ServiceAPI(this.transport.http),
                },
                team: {
                    api: new team_1.TeamAPI(this.transport.http),
                },
            };
            this.user = {
                api: new user_1.UserAPI(this.transport.http),
            };
        }
        init(clientType = client_1.ClientType.NONE, cookie) {
            return __awaiter(this, void 0, void 0, function* () {
                CookieStore_1.CookieStore.setCookie(cookie);
                const initialAccessToken = yield this.transport.http.refreshAccessToken();
                const context = this.createContext(initialAccessToken.user, clientType);
                yield this.accessTokenStore.updateToken(initialAccessToken);
                return context;
            });
        }
        login(loginData) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.context) {
                    yield this.logout({ ignoreError: true });
                }
                const accessToken = yield this.auth.api.postLogin(loginData);
                this.logger.info(`Saved initial access token. It will expire in "${accessToken.expires_in}" seconds.`, obfuscation_1.ObfuscationUtil.obfuscateAccessToken(accessToken));
                yield this.accessTokenStore.updateToken(accessToken);
                return this.createContext(accessToken.user, loginData.clientType);
            });
        }
        register(userAccount, clientType = client_1.ClientType.PERMANENT) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.context) {
                    yield this.logout({ ignoreError: true });
                }
                const user = yield this.auth.api.postRegister(userAccount);
                yield this.createContext(user.id, clientType);
                return this.init(clientType, CookieStore_1.CookieStore.getCookie());
            });
        }
        logout(options = { ignoreError: false }) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    this.disconnect('Closed by client logout');
                    yield this.auth.api.postLogout();
                }
                catch (error) {
                    if (options.ignoreError === true) {
                        this.logger.error(error);
                    }
                    else {
                        throw error;
                    }
                }
                finally {
                    CookieStore_1.CookieStore.deleteCookie();
                }
                yield this.accessTokenStore.delete();
                delete this.context;
            });
        }
        connect(onBeforeConnect) {
            var _a;
            return this.transport.ws.connect((_a = this.context) === null || _a === void 0 ? void 0 : _a.clientId, onBeforeConnect);
        }
        createContext(userId, clientType, clientId) {
            this.context = this.context ? Object.assign(Object.assign({}, this.context), { clientId, clientType }) : { clientId, clientType, userId };
            return this.context;
        }
        disconnect(reason) {
            this.transport.ws.disconnect(reason);
        }
        get clientId() {
            var _a;
            return ((_a = this.context) === null || _a === void 0 ? void 0 : _a.clientId) || undefined;
        }
        get userId() {
            var _a;
            return ((_a = this.context) === null || _a === void 0 ? void 0 : _a.userId) || undefined;
        }
        /** Should be used in cases where the user ID is MANDATORY. */
        get validatedUserId() {
            if (this.userId) {
                return this.userId;
            }
            throw new Error('No valid user ID.');
        }
        /** Should be used in cases where the client ID is MANDATORY. */
        get validatedClientId() {
            if (this.clientId) {
                return this.clientId;
            }
            throw new Error('No valid client ID.');
        }
    }
    APIClient.BACKEND = env_1.Backend;
    APIClient.TOPIC = TOPIC;
    APIClient.VERSION = version;
    return APIClient;
})();
exports.APIClient = APIClient;
//# sourceMappingURL=APIClient.js.map