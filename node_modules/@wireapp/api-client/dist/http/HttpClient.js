"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const commons_1 = require("@wireapp/commons");
const priority_queue_1 = require("@wireapp/priority-queue");
const axios_1 = __importDefault(require("axios"));
const events_1 = require("events");
const logdown_1 = __importDefault(require("logdown"));
const auth_1 = require("../auth/");
const http_1 = require("../http/");
const obfuscation_1 = require("../obfuscation/");
const cookie_1 = require("../shims/node/cookie");
var TOPIC;
(function (TOPIC) {
    TOPIC["ON_CONNECTION_STATE_CHANGE"] = "HttpClient.TOPIC.ON_CONNECTION_STATE_CHANGE";
})(TOPIC || (TOPIC = {}));
let HttpClient = /** @class */ (() => {
    class HttpClient extends events_1.EventEmitter {
        constructor(baseUrl, accessTokenStore) {
            super();
            this.baseUrl = baseUrl;
            this.accessTokenStore = accessTokenStore;
            this.connectionState = http_1.ConnectionState.UNDEFINED;
            this.logger = logdown_1.default('@wireapp/api-client/http/HttpClient', {
                logger: console,
                markdown: false,
            });
            this.requestQueue = new priority_queue_1.PriorityQueue({
                maxRetries: 0,
                retryDelay: commons_1.TimeUtil.TimeInMillis.SECOND,
            });
            // Log all failing HTTP requests
            axios_1.default.interceptors.response.use(undefined, (error) => {
                let backendResponse = '';
                if (error.response) {
                    try {
                        backendResponse = JSON.stringify(error.response.data);
                    }
                    finally {
                        this.logger.error(`HTTP Error (${error.response.status}) on '${error.response.config.url}': ${error.message} (${backendResponse})`);
                    }
                }
                return Promise.reject(error);
            });
        }
        updateConnectionState(state) {
            if (this.connectionState !== state) {
                this.connectionState = state;
                this.emit(HttpClient.TOPIC.ON_CONNECTION_STATE_CHANGE, this.connectionState);
            }
        }
        _sendRequest(config, tokenAsParam = false, firstTry = true) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                config.baseURL = this.baseUrl;
                if (this.accessTokenStore.accessToken) {
                    const { token_type, access_token } = this.accessTokenStore.accessToken;
                    if (tokenAsParam) {
                        config.params = Object.assign(Object.assign({}, config.params), { access_token });
                    }
                    else {
                        config.headers = Object.assign(Object.assign({}, config.headers), { Authorization: `${token_type} ${access_token}` });
                    }
                }
                try {
                    const response = yield axios_1.default.request(Object.assign(Object.assign({}, config), { maxContentLength: 104857600 }));
                    this.updateConnectionState(http_1.ConnectionState.CONNECTED);
                    return response;
                }
                catch (error) {
                    const { response, request } = error;
                    // Map Axios errors
                    const isNetworkError = !response && request && !Object.keys(request).length;
                    if (isNetworkError) {
                        const message = `Cannot do "${error.config.method}" request to "${error.config.url}".`;
                        const networkError = new http_1.NetworkError(message);
                        this.updateConnectionState(http_1.ConnectionState.DISCONNECTED);
                        throw networkError;
                    }
                    if (response) {
                        const { data: errorData, status: errorStatus } = response;
                        const isBackendError = (errorData === null || errorData === void 0 ? void 0 : errorData.code) && (errorData === null || errorData === void 0 ? void 0 : errorData.label) && (errorData === null || errorData === void 0 ? void 0 : errorData.message);
                        if (isBackendError) {
                            error = http_1.BackendErrorMapper.map(errorData);
                        }
                        else {
                            const isUnauthorized = errorStatus === http_1.StatusCode.UNAUTHORIZED;
                            const hasAccessToken = !!((_a = this.accessTokenStore) === null || _a === void 0 ? void 0 : _a.accessToken);
                            if (isUnauthorized && hasAccessToken && firstTry) {
                                yield this.refreshAccessToken();
                                return this._sendRequest(config, tokenAsParam, false);
                            }
                        }
                    }
                    throw error;
                }
            });
        }
        refreshAccessToken() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                let expiredAccessToken;
                if ((_a = this.accessTokenStore.accessToken) === null || _a === void 0 ? void 0 : _a.access_token) {
                    expiredAccessToken = this.accessTokenStore.accessToken;
                }
                const accessToken = yield this.postAccess(expiredAccessToken);
                this.logger.info(`Received updated access token. It will expire in "${accessToken.expires_in}" seconds.`, obfuscation_1.ObfuscationUtil.obfuscateAccessToken(accessToken));
                return this.accessTokenStore.updateToken(accessToken);
            });
        }
        postAccess(expiredAccessToken) {
            return __awaiter(this, void 0, void 0, function* () {
                const config = {
                    headers: {},
                    method: 'post',
                    url: `${auth_1.AuthAPI.URL.ACCESS}`,
                    withCredentials: true,
                };
                if (expiredAccessToken === null || expiredAccessToken === void 0 ? void 0 : expiredAccessToken.access_token) {
                    config.headers.Authorization = `${expiredAccessToken.token_type} ${decodeURIComponent(expiredAccessToken.access_token)}`;
                }
                const response = yield cookie_1.sendRequestWithCookie(this, config);
                return response.data;
            });
        }
        sendRequest(config, tokenAsParam = false, isSynchronousRequest = false) {
            return __awaiter(this, void 0, void 0, function* () {
                return isSynchronousRequest
                    ? this.requestQueue.add(() => this._sendRequest(config, tokenAsParam))
                    : this._sendRequest(config, tokenAsParam);
            });
        }
        sendJSON(config, isSynchronousRequest = false) {
            config.headers = Object.assign(Object.assign({}, config.headers), { 'Content-Type': http_1.ContentType.APPLICATION_JSON });
            return this.sendRequest(config, isSynchronousRequest);
        }
        sendXML(config, isSynchronousRequest = false) {
            config.headers = Object.assign(Object.assign({}, config.headers), { 'Content-Type': http_1.ContentType.APPLICATION_XML });
            return this.sendRequest(config, isSynchronousRequest);
        }
        sendProtocolBuffer(config, isSynchronousRequest = false) {
            config.headers['Content-Type'] = http_1.ContentType.APPLICATION_PROTOBUF;
            return this.sendRequest(config, isSynchronousRequest);
        }
    }
    HttpClient.TOPIC = TOPIC;
    return HttpClient;
})();
exports.HttpClient = HttpClient;
//# sourceMappingURL=HttpClient.js.map