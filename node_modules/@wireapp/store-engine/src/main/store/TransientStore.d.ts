/// <reference types="node" />
import { EventEmitter } from 'events';
import { TransientBundle } from './TransientBundle';
import type { CRUDEngine } from '../engine/';
import type { ExpiredBundle } from './ExpiredBundle';
declare enum TOPIC {
    EXPIRED = "expired"
}
export interface TransientStore {
    on(event: TOPIC.EXPIRED, listener: (bundle: ExpiredBundle) => void): this;
}
export declare class TransientStore extends EventEmitter {
    private readonly engine;
    static readonly TOPIC: typeof TOPIC;
    private readonly bundles;
    private tableName;
    constructor(engine: CRUDEngine);
    delete(primaryKey: string): Promise<string>;
    deleteFromCache(cacheKey: string): string;
    get(primaryKey: string): Promise<TransientBundle | undefined>;
    init(tableName: string): Promise<TransientBundle[]>;
    /**
     * Saves a transient record to the store and starts a timer to remove this record when the time to live (TTL) ended.
     * @param primaryKey Primary key from which the FQN is created
     * @param record A payload which should be kept in the TransientStore
     * @param ttl The time to live (TTL) in milliseconds (ex. 1000 is 1s)
     * @returns A transient bundle, wrapping the initial record
     */
    set<T>(primaryKey: string, record: T, ttl: number): Promise<TransientBundle>;
    /**
     * Returns a fully qualified name (FQN) which can be used to cache a transient bundle.
     * @param primaryKey Primary key from which the FQN is created
     * @returns A fully qualified name
     */
    private constructCacheKey;
    private constructPrimaryKey;
    private createTransientBundle;
    private deleteFromStore;
    private expireBundle;
    private getFromCache;
    private getFromStore;
    private save;
    private saveInCache;
    private saveInStore;
    private startTimer;
}
export {};
