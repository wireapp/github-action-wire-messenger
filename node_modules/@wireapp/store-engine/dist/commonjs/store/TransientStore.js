"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransientStore = void 0;
const events_1 = require("events");
const error_1 = require("../engine/error/");
const TransientBundle_1 = require("./TransientBundle");
var TOPIC;
(function (TOPIC) {
    TOPIC["EXPIRED"] = "expired";
})(TOPIC || (TOPIC = {}));
let TransientStore = /** @class */ (() => {
    class TransientStore extends events_1.EventEmitter {
        constructor(engine) {
            super();
            this.engine = engine;
            this.bundles = {};
            this.tableName = '';
        }
        delete(primaryKey) {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheKey = this.constructCacheKey(primaryKey);
                yield Promise.all([this.deleteFromStore(primaryKey), this.deleteFromCache(cacheKey)]);
                return cacheKey;
            });
        }
        deleteFromCache(cacheKey) {
            var _a;
            const timeoutID = (_a = this.bundles[cacheKey]) === null || _a === void 0 ? void 0 : _a.timeoutID;
            if (timeoutID) {
                clearTimeout(timeoutID);
            }
            delete this.bundles[cacheKey];
            return cacheKey;
        }
        get(primaryKey) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const cachedBundle = yield this.getFromCache(primaryKey);
                    return cachedBundle !== undefined ? cachedBundle : yield this.getFromStore(primaryKey);
                }
                catch (error) {
                    if (error instanceof error_1.RecordNotFoundError) {
                        return undefined;
                    }
                    throw error;
                }
            });
        }
        init(tableName) {
            return __awaiter(this, void 0, void 0, function* () {
                this.tableName = tableName;
                const cacheKeys = [];
                const primaryKeys = yield this.engine.readAllPrimaryKeys(this.tableName);
                const readBundles = primaryKeys.map(primaryKey => {
                    const cacheKey = this.constructCacheKey(primaryKey);
                    cacheKeys.push(cacheKey);
                    return this.engine.read(this.tableName, primaryKey);
                });
                const bundles = yield Promise.all(readBundles);
                for (const index in bundles) {
                    const bundle = bundles[index];
                    const cacheKey = cacheKeys[index];
                    yield this.startTimer(cacheKey);
                    this.bundles[cacheKey] = bundle;
                }
                return bundles;
            });
        }
        /**
         * Saves a transient record to the store and starts a timer to remove this record when the time to live (TTL) ended.
         * @param primaryKey Primary key from which the FQN is created
         * @param record A payload which should be kept in the TransientStore
         * @param ttl The time to live (TTL) in milliseconds (ex. 1000 is 1s)
         * @returns A transient bundle, wrapping the initial record
         */
        set(primaryKey, record, ttl) {
            return __awaiter(this, void 0, void 0, function* () {
                const bundle = this.createTransientBundle(record, ttl);
                const cachedBundle = yield this.getFromCache(primaryKey);
                if (cachedBundle) {
                    const message = `Record with primary key "${primaryKey}" already exists in table "${this.tableName}" of database "${this.engine.storeName}".`;
                    throw new error_1.RecordAlreadyExistsError(message);
                }
                else {
                    const cacheKey = yield this.save(primaryKey, bundle);
                    const transientBundle = yield this.startTimer(cacheKey);
                    // Note: Save bundle with timeoutID in cache (not in persistent storage)
                    return this.saveInCache(cacheKey, transientBundle);
                }
            });
        }
        /**
         * Returns a fully qualified name (FQN) which can be used to cache a transient bundle.
         * @param primaryKey Primary key from which the FQN is created
         * @returns A fully qualified name
         */
        constructCacheKey(primaryKey) {
            return `${this.engine.storeName}@${this.tableName}@${primaryKey}`;
        }
        constructPrimaryKey(cacheKey) {
            return cacheKey.replace(`${this.engine.storeName}@${this.tableName}@`, '');
        }
        createTransientBundle(record, ttl) {
            return {
                expires: Date.now() + ttl,
                payload: record,
            };
        }
        deleteFromStore(primaryKey) {
            return this.engine.delete(this.tableName, primaryKey);
        }
        expireBundle(cacheKey) {
            return __awaiter(this, void 0, void 0, function* () {
                const expiredBundle = {
                    cacheKey: cacheKey,
                    payload: this.bundles[cacheKey].payload,
                    primaryKey: this.constructPrimaryKey(cacheKey),
                };
                yield this.delete(expiredBundle.primaryKey);
                return expiredBundle;
            });
        }
        getFromCache(primaryKey) {
            const cacheBundle = this.bundles[this.constructCacheKey(primaryKey)];
            return Promise.resolve(cacheBundle);
        }
        getFromStore(primaryKey) {
            return this.engine.read(this.tableName, primaryKey);
        }
        save(primaryKey, bundle) {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheKey = this.constructCacheKey(primaryKey);
                yield Promise.all([this.saveInStore(primaryKey, bundle), this.saveInCache(cacheKey, bundle)]);
                return cacheKey;
            });
        }
        saveInCache(cacheKey, bundle) {
            return (this.bundles[cacheKey] = bundle);
        }
        saveInStore(primaryKey, bundle) {
            return this.engine.create(this.tableName, primaryKey, bundle);
        }
        startTimer(cacheKey) {
            return __awaiter(this, void 0, void 0, function* () {
                const primaryKey = this.constructPrimaryKey(cacheKey);
                let bundle = yield this.get(primaryKey);
                if (!bundle) {
                    bundle = new TransientBundle_1.TransientBundle();
                    bundle.expires = 0;
                    bundle.payload = undefined;
                }
                const { expires, timeoutID } = bundle;
                const timespan = expires - Date.now();
                if (expires <= 0) {
                    yield this.expireBundle(cacheKey);
                }
                else if (!timeoutID) {
                    bundle.timeoutID = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        const expiredBundle = yield this.expireBundle(cacheKey);
                        this.emit(TransientStore.TOPIC.EXPIRED, expiredBundle);
                    }), timespan);
                }
                return bundle;
            });
        }
    }
    TransientStore.TOPIC = TOPIC;
    return TransientStore;
})();
exports.TransientStore = TransientStore;
//# sourceMappingURL=TransientStore.js.map