import * as $protobuf from "protobufjs";
export interface IGenericMessage {
    messageId: string;
    text?: (IText|null);
    image?: (IImageAsset|null);
    knock?: (IKnock|null);
    lastRead?: (ILastRead|null);
    cleared?: (ICleared|null);
    external?: (IExternal|null);
    clientAction?: (ClientAction|null);
    calling?: (ICalling|null);
    asset?: (IAsset|null);
    hidden?: (IMessageHide|null);
    location?: (ILocation|null);
    deleted?: (IMessageDelete|null);
    edited?: (IMessageEdit|null);
    confirmation?: (IConfirmation|null);
    reaction?: (IReaction|null);
    ephemeral?: (IEphemeral|null);
    availability?: (IAvailability|null);
    composite?: (IComposite|null);
    buttonAction?: (IButtonAction|null);
    buttonActionConfirmation?: (IButtonActionConfirmation|null);
    dataTransfer?: (IDataTransfer|null);
}

export class GenericMessage implements IGenericMessage {
    constructor(properties?: IGenericMessage);
    public messageId: string;
    public text?: (IText|null);
    public image?: (IImageAsset|null);
    public knock?: (IKnock|null);
    public lastRead?: (ILastRead|null);
    public cleared?: (ICleared|null);
    public external?: (IExternal|null);
    public clientAction: ClientAction;
    public calling?: (ICalling|null);
    public asset?: (IAsset|null);
    public hidden?: (IMessageHide|null);
    public location?: (ILocation|null);
    public deleted?: (IMessageDelete|null);
    public edited?: (IMessageEdit|null);
    public confirmation?: (IConfirmation|null);
    public reaction?: (IReaction|null);
    public ephemeral?: (IEphemeral|null);
    public availability?: (IAvailability|null);
    public composite?: (IComposite|null);
    public buttonAction?: (IButtonAction|null);
    public buttonActionConfirmation?: (IButtonActionConfirmation|null);
    public dataTransfer?: (IDataTransfer|null);
    public content?: ("text"|"image"|"knock"|"lastRead"|"cleared"|"external"|"clientAction"|"calling"|"asset"|"hidden"|"location"|"deleted"|"edited"|"confirmation"|"reaction"|"ephemeral"|"availability"|"composite"|"buttonAction"|"buttonActionConfirmation"|"dataTransfer");
    public static create(properties?: IGenericMessage): GenericMessage;
    public static encode(message: IGenericMessage, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IGenericMessage, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): GenericMessage;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): GenericMessage;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): GenericMessage;
    public static toObject(message: GenericMessage, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IQualifiedUserId {
    id: string;
    domain: string;
}

export class QualifiedUserId implements IQualifiedUserId {
    constructor(properties?: IQualifiedUserId);
    public id: string;
    public domain: string;
    public static create(properties?: IQualifiedUserId): QualifiedUserId;
    public static encode(message: IQualifiedUserId, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IQualifiedUserId, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): QualifiedUserId;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): QualifiedUserId;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): QualifiedUserId;
    public static toObject(message: QualifiedUserId, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IQualifiedConversationId {
    id: string;
    domain: string;
}

export class QualifiedConversationId implements IQualifiedConversationId {
    constructor(properties?: IQualifiedConversationId);
    public id: string;
    public domain: string;
    public static create(properties?: IQualifiedConversationId): QualifiedConversationId;
    public static encode(message: IQualifiedConversationId, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IQualifiedConversationId, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): QualifiedConversationId;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): QualifiedConversationId;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): QualifiedConversationId;
    public static toObject(message: QualifiedConversationId, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IComposite {
    items?: (Composite.IItem[]|null);
    expectsReadConfirmation?: (boolean|null);
    legalHoldStatus?: (LegalHoldStatus|null);
}

export class Composite implements IComposite {
    constructor(properties?: IComposite);
    public items: Composite.IItem[];
    public expectsReadConfirmation: boolean;
    public legalHoldStatus: LegalHoldStatus;
    public static create(properties?: IComposite): Composite;
    public static encode(message: IComposite, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IComposite, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Composite;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Composite;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Composite;
    public static toObject(message: Composite, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export namespace Composite {

    interface IItem {
        text?: (IText|null);
        button?: (IButton|null);
    }

    class Item implements IItem {
        constructor(properties?: Composite.IItem);
        public text?: (IText|null);
        public button?: (IButton|null);
        public content?: ("text"|"button");
        public static create(properties?: Composite.IItem): Composite.Item;
        public static encode(message: Composite.IItem, writer?: $protobuf.Writer): $protobuf.Writer;
        public static encodeDelimited(message: Composite.IItem, writer?: $protobuf.Writer): $protobuf.Writer;
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Composite.Item;
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Composite.Item;
        public static verify(message: { [k: string]: any }): (string|null);
        public static fromObject(object: { [k: string]: any }): Composite.Item;
        public static toObject(message: Composite.Item, options?: $protobuf.IConversionOptions): { [k: string]: any };
        public toJSON(): { [k: string]: any };
    }
}

export interface IButton {
    text: string;
    id: string;
}

export class Button implements IButton {
    constructor(properties?: IButton);
    public text: string;
    public id: string;
    public static create(properties?: IButton): Button;
    public static encode(message: IButton, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IButton, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Button;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Button;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Button;
    public static toObject(message: Button, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IButtonAction {
    buttonId: string;
    referenceMessageId: string;
}

export class ButtonAction implements IButtonAction {
    constructor(properties?: IButtonAction);
    public buttonId: string;
    public referenceMessageId: string;
    public static create(properties?: IButtonAction): ButtonAction;
    public static encode(message: IButtonAction, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IButtonAction, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ButtonAction;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ButtonAction;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): ButtonAction;
    public static toObject(message: ButtonAction, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IButtonActionConfirmation {
    referenceMessageId: string;
    buttonId?: (string|null);
}

export class ButtonActionConfirmation implements IButtonActionConfirmation {
    constructor(properties?: IButtonActionConfirmation);
    public referenceMessageId: string;
    public buttonId: string;
    public static create(properties?: IButtonActionConfirmation): ButtonActionConfirmation;
    public static encode(message: IButtonActionConfirmation, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IButtonActionConfirmation, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ButtonActionConfirmation;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ButtonActionConfirmation;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): ButtonActionConfirmation;
    public static toObject(message: ButtonActionConfirmation, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IAvailability {
    type: Availability.Type;
}

export class Availability implements IAvailability {
    constructor(properties?: IAvailability);
    public type: Availability.Type;
    public static create(properties?: IAvailability): Availability;
    public static encode(message: IAvailability, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IAvailability, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Availability;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Availability;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Availability;
    public static toObject(message: Availability, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export namespace Availability {

    enum Type {
        NONE = 0,
        AVAILABLE = 1,
        AWAY = 2,
        BUSY = 3
    }
}

export interface IEphemeral {
    expireAfterMillis: (number|Long);
    text?: (IText|null);
    image?: (IImageAsset|null);
    knock?: (IKnock|null);
    asset?: (IAsset|null);
    location?: (ILocation|null);
}

export class Ephemeral implements IEphemeral {
    constructor(properties?: IEphemeral);
    public expireAfterMillis: (number|Long);
    public text?: (IText|null);
    public image?: (IImageAsset|null);
    public knock?: (IKnock|null);
    public asset?: (IAsset|null);
    public location?: (ILocation|null);
    public content?: ("text"|"image"|"knock"|"asset"|"location");
    public static create(properties?: IEphemeral): Ephemeral;
    public static encode(message: IEphemeral, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IEphemeral, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Ephemeral;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Ephemeral;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Ephemeral;
    public static toObject(message: Ephemeral, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IText {
    content: string;
    linkPreview?: (ILinkPreview[]|null);
    mentions?: (IMention[]|null);
    quote?: (IQuote|null);
    expectsReadConfirmation?: (boolean|null);
    legalHoldStatus?: (LegalHoldStatus|null);
}

export class Text implements IText {
    constructor(properties?: IText);
    public content: string;
    public linkPreview: ILinkPreview[];
    public mentions: IMention[];
    public quote?: (IQuote|null);
    public expectsReadConfirmation: boolean;
    public legalHoldStatus: LegalHoldStatus;
    public static create(properties?: IText): Text;
    public static encode(message: IText, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IText, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Text;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Text;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Text;
    public static toObject(message: Text, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IKnock {
    hotKnock: boolean;
    expectsReadConfirmation?: (boolean|null);
    legalHoldStatus?: (LegalHoldStatus|null);
}

export class Knock implements IKnock {
    constructor(properties?: IKnock);
    public hotKnock: boolean;
    public expectsReadConfirmation: boolean;
    public legalHoldStatus: LegalHoldStatus;
    public static create(properties?: IKnock): Knock;
    public static encode(message: IKnock, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IKnock, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Knock;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Knock;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Knock;
    public static toObject(message: Knock, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface ILinkPreview {
    url: string;
    urlOffset: number;
    article?: (IArticle|null);
    permanentUrl?: (string|null);
    title?: (string|null);
    summary?: (string|null);
    image?: (IAsset|null);
    tweet?: (ITweet|null);
}

export class LinkPreview implements ILinkPreview {
    constructor(properties?: ILinkPreview);
    public url: string;
    public urlOffset: number;
    public article?: (IArticle|null);
    public permanentUrl: string;
    public title: string;
    public summary: string;
    public image?: (IAsset|null);
    public tweet?: (ITweet|null);
    public preview?: "article";
    public metaData?: "tweet";
    public static create(properties?: ILinkPreview): LinkPreview;
    public static encode(message: ILinkPreview, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: ILinkPreview, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): LinkPreview;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): LinkPreview;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): LinkPreview;
    public static toObject(message: LinkPreview, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface ITweet {
    author?: (string|null);
    username?: (string|null);
}

export class Tweet implements ITweet {
    constructor(properties?: ITweet);
    public author: string;
    public username: string;
    public static create(properties?: ITweet): Tweet;
    public static encode(message: ITweet, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: ITweet, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Tweet;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Tweet;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Tweet;
    public static toObject(message: Tweet, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IArticle {
    permanentUrl: string;
    title?: (string|null);
    summary?: (string|null);
    image?: (IAsset|null);
}

export class Article implements IArticle {
    constructor(properties?: IArticle);
    public permanentUrl: string;
    public title: string;
    public summary: string;
    public image?: (IAsset|null);
    public static create(properties?: IArticle): Article;
    public static encode(message: IArticle, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IArticle, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Article;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Article;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Article;
    public static toObject(message: Article, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IMention {
    start: number;
    length: number;
    userId?: (string|null);
    qualifiedUserId?: (IQualifiedUserId|null);
}

export class Mention implements IMention {
    constructor(properties?: IMention);
    public start: number;
    public length: number;
    public userId: string;
    public qualifiedUserId?: (IQualifiedUserId|null);
    public mentionType?: "userId";
    public static create(properties?: IMention): Mention;
    public static encode(message: IMention, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IMention, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Mention;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Mention;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Mention;
    public static toObject(message: Mention, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface ILastRead {
    conversationId: string;
    lastReadTimestamp: (number|Long);
    qualifiedConversationId?: (IQualifiedConversationId|null);
}

export class LastRead implements ILastRead {
    constructor(properties?: ILastRead);
    public conversationId: string;
    public lastReadTimestamp: (number|Long);
    public qualifiedConversationId?: (IQualifiedConversationId|null);
    public static create(properties?: ILastRead): LastRead;
    public static encode(message: ILastRead, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: ILastRead, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): LastRead;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): LastRead;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): LastRead;
    public static toObject(message: LastRead, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface ICleared {
    conversationId: string;
    clearedTimestamp: (number|Long);
    qualifiedConversationId?: (IQualifiedConversationId|null);
}

export class Cleared implements ICleared {
    constructor(properties?: ICleared);
    public conversationId: string;
    public clearedTimestamp: (number|Long);
    public qualifiedConversationId?: (IQualifiedConversationId|null);
    public static create(properties?: ICleared): Cleared;
    public static encode(message: ICleared, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: ICleared, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Cleared;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Cleared;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Cleared;
    public static toObject(message: Cleared, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IMessageHide {
    conversationId: string;
    messageId: string;
    qualifiedConversationId?: (IQualifiedConversationId|null);
}

export class MessageHide implements IMessageHide {
    constructor(properties?: IMessageHide);
    public conversationId: string;
    public messageId: string;
    public qualifiedConversationId?: (IQualifiedConversationId|null);
    public static create(properties?: IMessageHide): MessageHide;
    public static encode(message: IMessageHide, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IMessageHide, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MessageHide;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MessageHide;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): MessageHide;
    public static toObject(message: MessageHide, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IMessageDelete {
    messageId: string;
}

export class MessageDelete implements IMessageDelete {
    constructor(properties?: IMessageDelete);
    public messageId: string;
    public static create(properties?: IMessageDelete): MessageDelete;
    public static encode(message: IMessageDelete, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IMessageDelete, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MessageDelete;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MessageDelete;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): MessageDelete;
    public static toObject(message: MessageDelete, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IMessageEdit {
    replacingMessageId: string;
    text?: (IText|null);
    composite?: (IComposite|null);
}

export class MessageEdit implements IMessageEdit {
    constructor(properties?: IMessageEdit);
    public replacingMessageId: string;
    public text?: (IText|null);
    public composite?: (IComposite|null);
    public content?: ("text"|"composite");
    public static create(properties?: IMessageEdit): MessageEdit;
    public static encode(message: IMessageEdit, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IMessageEdit, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): MessageEdit;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): MessageEdit;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): MessageEdit;
    public static toObject(message: MessageEdit, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IQuote {
    quotedMessageId: string;
    quotedMessageSha256?: (Uint8Array|null);
}

export class Quote implements IQuote {
    constructor(properties?: IQuote);
    public quotedMessageId: string;
    public quotedMessageSha256: Uint8Array;
    public static create(properties?: IQuote): Quote;
    public static encode(message: IQuote, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IQuote, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Quote;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Quote;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Quote;
    public static toObject(message: Quote, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IConfirmation {
    type: Confirmation.Type;
    firstMessageId: string;
    moreMessageIds?: (string[]|null);
}

export class Confirmation implements IConfirmation {
    constructor(properties?: IConfirmation);
    public type: Confirmation.Type;
    public firstMessageId: string;
    public moreMessageIds: string[];
    public static create(properties?: IConfirmation): Confirmation;
    public static encode(message: IConfirmation, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IConfirmation, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Confirmation;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Confirmation;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Confirmation;
    public static toObject(message: Confirmation, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export namespace Confirmation {

    enum Type {
        DELIVERED = 0,
        READ = 1
    }
}

export interface ILocation {
    longitude: number;
    latitude: number;
    name?: (string|null);
    zoom?: (number|null);
    expectsReadConfirmation?: (boolean|null);
    legalHoldStatus?: (LegalHoldStatus|null);
}

export class Location implements ILocation {
    constructor(properties?: ILocation);
    public longitude: number;
    public latitude: number;
    public name: string;
    public zoom: number;
    public expectsReadConfirmation: boolean;
    public legalHoldStatus: LegalHoldStatus;
    public static create(properties?: ILocation): Location;
    public static encode(message: ILocation, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: ILocation, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Location;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Location;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Location;
    public static toObject(message: Location, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IImageAsset {
    tag: string;
    width: number;
    height: number;
    originalWidth: number;
    originalHeight: number;
    mimeType: string;
    size: number;
    otrKey?: (Uint8Array|null);
    macKey?: (Uint8Array|null);
    mac?: (Uint8Array|null);
    sha256?: (Uint8Array|null);
}

export class ImageAsset implements IImageAsset {
    constructor(properties?: IImageAsset);
    public tag: string;
    public width: number;
    public height: number;
    public originalWidth: number;
    public originalHeight: number;
    public mimeType: string;
    public size: number;
    public otrKey: Uint8Array;
    public macKey: Uint8Array;
    public mac: Uint8Array;
    public sha256: Uint8Array;
    public static create(properties?: IImageAsset): ImageAsset;
    public static encode(message: IImageAsset, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IImageAsset, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): ImageAsset;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): ImageAsset;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): ImageAsset;
    public static toObject(message: ImageAsset, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IAsset {
    original?: (Asset.IOriginal|null);
    notUploaded?: (Asset.NotUploaded|null);
    uploaded?: (Asset.IRemoteData|null);
    preview?: (Asset.IPreview|null);
    expectsReadConfirmation?: (boolean|null);
    legalHoldStatus?: (LegalHoldStatus|null);
}

export class Asset implements IAsset {
    constructor(properties?: IAsset);
    public original?: (Asset.IOriginal|null);
    public notUploaded: Asset.NotUploaded;
    public uploaded?: (Asset.IRemoteData|null);
    public preview?: (Asset.IPreview|null);
    public expectsReadConfirmation: boolean;
    public legalHoldStatus: LegalHoldStatus;
    public status?: ("notUploaded"|"uploaded");
    public static create(properties?: IAsset): Asset;
    public static encode(message: IAsset, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IAsset, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Asset;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Asset;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Asset;
    public static toObject(message: Asset, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export namespace Asset {

    interface IOriginal {
        mimeType: string;
        size: (number|Long);
        name?: (string|null);
        image?: (Asset.IImageMetaData|null);
        video?: (Asset.IVideoMetaData|null);
        audio?: (Asset.IAudioMetaData|null);
        source?: (string|null);
        caption?: (string|null);
    }

    class Original implements IOriginal {
        constructor(properties?: Asset.IOriginal);
        public mimeType: string;
        public size: (number|Long);
        public name: string;
        public image?: (Asset.IImageMetaData|null);
        public video?: (Asset.IVideoMetaData|null);
        public audio?: (Asset.IAudioMetaData|null);
        public source: string;
        public caption: string;
        public metaData?: ("image"|"video"|"audio");
        public static create(properties?: Asset.IOriginal): Asset.Original;
        public static encode(message: Asset.IOriginal, writer?: $protobuf.Writer): $protobuf.Writer;
        public static encodeDelimited(message: Asset.IOriginal, writer?: $protobuf.Writer): $protobuf.Writer;
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Asset.Original;
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Asset.Original;
        public static verify(message: { [k: string]: any }): (string|null);
        public static fromObject(object: { [k: string]: any }): Asset.Original;
        public static toObject(message: Asset.Original, options?: $protobuf.IConversionOptions): { [k: string]: any };
        public toJSON(): { [k: string]: any };
    }

    interface IPreview {
        mimeType: string;
        size: (number|Long);
        remote?: (Asset.IRemoteData|null);
        image?: (Asset.IImageMetaData|null);
    }

    class Preview implements IPreview {
        constructor(properties?: Asset.IPreview);
        public mimeType: string;
        public size: (number|Long);
        public remote?: (Asset.IRemoteData|null);
        public image?: (Asset.IImageMetaData|null);
        public metaData?: "image";
        public static create(properties?: Asset.IPreview): Asset.Preview;
        public static encode(message: Asset.IPreview, writer?: $protobuf.Writer): $protobuf.Writer;
        public static encodeDelimited(message: Asset.IPreview, writer?: $protobuf.Writer): $protobuf.Writer;
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Asset.Preview;
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Asset.Preview;
        public static verify(message: { [k: string]: any }): (string|null);
        public static fromObject(object: { [k: string]: any }): Asset.Preview;
        public static toObject(message: Asset.Preview, options?: $protobuf.IConversionOptions): { [k: string]: any };
        public toJSON(): { [k: string]: any };
    }

    interface IImageMetaData {
        width: number;
        height: number;
        tag?: (string|null);
    }

    class ImageMetaData implements IImageMetaData {
        constructor(properties?: Asset.IImageMetaData);
        public width: number;
        public height: number;
        public tag: string;
        public static create(properties?: Asset.IImageMetaData): Asset.ImageMetaData;
        public static encode(message: Asset.IImageMetaData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static encodeDelimited(message: Asset.IImageMetaData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Asset.ImageMetaData;
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Asset.ImageMetaData;
        public static verify(message: { [k: string]: any }): (string|null);
        public static fromObject(object: { [k: string]: any }): Asset.ImageMetaData;
        public static toObject(message: Asset.ImageMetaData, options?: $protobuf.IConversionOptions): { [k: string]: any };
        public toJSON(): { [k: string]: any };
    }

    interface IVideoMetaData {
        width?: (number|null);
        height?: (number|null);
        durationInMillis?: (number|Long|null);
    }

    class VideoMetaData implements IVideoMetaData {
        constructor(properties?: Asset.IVideoMetaData);
        public width: number;
        public height: number;
        public durationInMillis: (number|Long);
        public static create(properties?: Asset.IVideoMetaData): Asset.VideoMetaData;
        public static encode(message: Asset.IVideoMetaData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static encodeDelimited(message: Asset.IVideoMetaData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Asset.VideoMetaData;
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Asset.VideoMetaData;
        public static verify(message: { [k: string]: any }): (string|null);
        public static fromObject(object: { [k: string]: any }): Asset.VideoMetaData;
        public static toObject(message: Asset.VideoMetaData, options?: $protobuf.IConversionOptions): { [k: string]: any };
        public toJSON(): { [k: string]: any };
    }

    interface IAudioMetaData {
        durationInMillis?: (number|Long|null);
        normalizedLoudness?: (Uint8Array|null);
    }

    class AudioMetaData implements IAudioMetaData {
        constructor(properties?: Asset.IAudioMetaData);
        public durationInMillis: (number|Long);
        public normalizedLoudness: Uint8Array;
        public static create(properties?: Asset.IAudioMetaData): Asset.AudioMetaData;
        public static encode(message: Asset.IAudioMetaData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static encodeDelimited(message: Asset.IAudioMetaData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Asset.AudioMetaData;
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Asset.AudioMetaData;
        public static verify(message: { [k: string]: any }): (string|null);
        public static fromObject(object: { [k: string]: any }): Asset.AudioMetaData;
        public static toObject(message: Asset.AudioMetaData, options?: $protobuf.IConversionOptions): { [k: string]: any };
        public toJSON(): { [k: string]: any };
    }

    enum NotUploaded {
        CANCELLED = 0,
        FAILED = 1
    }

    interface IRemoteData {
        otrKey: Uint8Array;
        sha256: Uint8Array;
        assetId?: (string|null);
        assetToken?: (string|null);
        encryption?: (EncryptionAlgorithm|null);
    }

    class RemoteData implements IRemoteData {
        constructor(properties?: Asset.IRemoteData);
        public otrKey: Uint8Array;
        public sha256: Uint8Array;
        public assetId: string;
        public assetToken: string;
        public encryption: EncryptionAlgorithm;
        public static create(properties?: Asset.IRemoteData): Asset.RemoteData;
        public static encode(message: Asset.IRemoteData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static encodeDelimited(message: Asset.IRemoteData, writer?: $protobuf.Writer): $protobuf.Writer;
        public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Asset.RemoteData;
        public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Asset.RemoteData;
        public static verify(message: { [k: string]: any }): (string|null);
        public static fromObject(object: { [k: string]: any }): Asset.RemoteData;
        public static toObject(message: Asset.RemoteData, options?: $protobuf.IConversionOptions): { [k: string]: any };
        public toJSON(): { [k: string]: any };
    }
}

export interface IExternal {
    otrKey: Uint8Array;
    sha256?: (Uint8Array|null);
    encryption?: (EncryptionAlgorithm|null);
}

export class External implements IExternal {
    constructor(properties?: IExternal);
    public otrKey: Uint8Array;
    public sha256: Uint8Array;
    public encryption: EncryptionAlgorithm;
    public static create(properties?: IExternal): External;
    public static encode(message: IExternal, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IExternal, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): External;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): External;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): External;
    public static toObject(message: External, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IReaction {
    emoji?: (string|null);
    messageId: string;
    legalHoldStatus?: (LegalHoldStatus|null);
}

export class Reaction implements IReaction {
    constructor(properties?: IReaction);
    public emoji: string;
    public messageId: string;
    public legalHoldStatus: LegalHoldStatus;
    public static create(properties?: IReaction): Reaction;
    public static encode(message: IReaction, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IReaction, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Reaction;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Reaction;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Reaction;
    public static toObject(message: Reaction, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface ICalling {
    content: string;
}

export class Calling implements ICalling {
    constructor(properties?: ICalling);
    public content: string;
    public static create(properties?: ICalling): Calling;
    public static encode(message: ICalling, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: ICalling, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): Calling;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): Calling;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): Calling;
    public static toObject(message: Calling, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface IDataTransfer {
    trackingIdentifier?: (ITrackingIdentifier|null);
}

export class DataTransfer implements IDataTransfer {
    constructor(properties?: IDataTransfer);
    public trackingIdentifier?: (ITrackingIdentifier|null);
    public static create(properties?: IDataTransfer): DataTransfer;
    public static encode(message: IDataTransfer, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: IDataTransfer, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): DataTransfer;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): DataTransfer;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): DataTransfer;
    public static toObject(message: DataTransfer, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export interface ITrackingIdentifier {
    identifier: string;
}

export class TrackingIdentifier implements ITrackingIdentifier {
    constructor(properties?: ITrackingIdentifier);
    public identifier: string;
    public static create(properties?: ITrackingIdentifier): TrackingIdentifier;
    public static encode(message: ITrackingIdentifier, writer?: $protobuf.Writer): $protobuf.Writer;
    public static encodeDelimited(message: ITrackingIdentifier, writer?: $protobuf.Writer): $protobuf.Writer;
    public static decode(reader: ($protobuf.Reader|Uint8Array), length?: number): TrackingIdentifier;
    public static decodeDelimited(reader: ($protobuf.Reader|Uint8Array)): TrackingIdentifier;
    public static verify(message: { [k: string]: any }): (string|null);
    public static fromObject(object: { [k: string]: any }): TrackingIdentifier;
    public static toObject(message: TrackingIdentifier, options?: $protobuf.IConversionOptions): { [k: string]: any };
    public toJSON(): { [k: string]: any };
}

export enum ClientAction {
    RESET_SESSION = 0
}

export enum EncryptionAlgorithm {
    AES_CBC = 0,
    AES_GCM = 1
}

export enum LegalHoldStatus {
    UNKNOWN = 0,
    DISABLED = 1,
    ENABLED = 2
}
