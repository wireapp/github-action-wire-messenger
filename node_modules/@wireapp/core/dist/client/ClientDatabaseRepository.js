"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientDatabaseRepository = exports.DatabaseStores = void 0;
const cryptography_1 = require("../cryptography/");
var DatabaseStores;
(function (DatabaseStores) {
    DatabaseStores["CLIENTS"] = "clients";
})(DatabaseStores = exports.DatabaseStores || (exports.DatabaseStores = {}));
let ClientDatabaseRepository = /** @class */ (() => {
    class ClientDatabaseRepository {
        constructor(storeEngine) {
            this.storeEngine = storeEngine;
        }
        getLocalClient() {
            return this.getClient(ClientDatabaseRepository.KEYS.LOCAL_IDENTITY);
        }
        getClient(sessionId) {
            return this.storeEngine.read(ClientDatabaseRepository.STORES.CLIENTS, sessionId);
        }
        deleteLocalClient() {
            return this.storeEngine.delete(ClientDatabaseRepository.STORES.CLIENTS, ClientDatabaseRepository.KEYS.LOCAL_IDENTITY);
        }
        deleteClient(sessionId) {
            return this.storeEngine.delete(ClientDatabaseRepository.STORES.CLIENTS, sessionId);
        }
        createClientList(userId, clientList) {
            const createClientTasks = [];
            for (const client of clientList) {
                createClientTasks.push(this.createClient(userId, client));
            }
            return Promise.all(createClientTasks);
        }
        createLocalClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                const transformedClient = this.transformLocalClient(client);
                yield this.storeEngine.create(ClientDatabaseRepository.STORES.CLIENTS, ClientDatabaseRepository.KEYS.LOCAL_IDENTITY, transformedClient);
                return transformedClient;
            });
        }
        updateLocalClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                const transformedClient = this.transformLocalClient(client);
                yield this.storeEngine.update(ClientDatabaseRepository.STORES.CLIENTS, ClientDatabaseRepository.KEYS.LOCAL_IDENTITY, transformedClient);
                return transformedClient;
            });
        }
        updateClient(userId, client) {
            return __awaiter(this, void 0, void 0, function* () {
                const transformedClient = this.transformClient(userId, client);
                yield this.storeEngine.update(ClientDatabaseRepository.STORES.CLIENTS, cryptography_1.CryptographyService.constructSessionId(userId, client.id), transformedClient);
                return transformedClient;
            });
        }
        createClient(userId, client) {
            return __awaiter(this, void 0, void 0, function* () {
                const transformedClient = this.transformClient(userId, client);
                yield this.storeEngine.create(ClientDatabaseRepository.STORES.CLIENTS, cryptography_1.CryptographyService.constructSessionId(userId, client.id), transformedClient);
                return transformedClient;
            });
        }
        transformClient(userId, client, verified = false) {
            return Object.assign(Object.assign({}, client), { meta: { is_verified: verified, primary_key: cryptography_1.CryptographyService.constructSessionId(userId, client.id) } });
        }
        transformLocalClient(client, verified = true) {
            return Object.assign(Object.assign({}, client), { meta: { is_verified: verified, primary_key: ClientDatabaseRepository.KEYS.LOCAL_IDENTITY } });
        }
    }
    ClientDatabaseRepository.STORES = DatabaseStores;
    ClientDatabaseRepository.KEYS = {
        LOCAL_IDENTITY: 'local_identity',
    };
    return ClientDatabaseRepository;
})();
exports.ClientDatabaseRepository = ClientDatabaseRepository;
//# sourceMappingURL=ClientDatabaseRepository.js.map