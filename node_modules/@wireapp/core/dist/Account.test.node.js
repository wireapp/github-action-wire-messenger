"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_client_1 = require("@wireapp/api-client");
const auth_1 = require("@wireapp/api-client/dist/auth");
const client_1 = require("@wireapp/api-client/dist/client");
const conversation_1 = require("@wireapp/api-client/dist/conversation");
const http_1 = require("@wireapp/api-client/dist/http");
const notification_1 = require("@wireapp/api-client/dist/notification");
const commons_1 = require("@wireapp/commons");
const protocol_messaging_1 = require("@wireapp/protocol-messaging");
const store_engine_1 = require("@wireapp/store-engine");
const nock = require("nock");
const Account_1 = require("./Account");
const conversation_2 = require("./conversation");
const BASE_URL = 'mock-backend.wire.com';
const MOCK_BACKEND = {
    name: 'mock',
    rest: `https://${BASE_URL}`,
    ws: `wss://${BASE_URL}`,
};
function createAccount(storageName = `test-${Date.now()}`) {
    return __awaiter(this, void 0, void 0, function* () {
        const apiClient = new api_client_1.APIClient({ urls: MOCK_BACKEND });
        const account = new Account_1.Account(apiClient);
        yield account.initServices(new store_engine_1.MemoryEngine());
        return account;
    });
}
describe('Account', () => {
    const CLIENT_ID = '4e37b32f57f6da55';
    const accessTokenData = {
        access_token: 'iJCRCjc8oROO-dkrkqCXOade997oa8Jhbz6awMUQPBQo80VenWqp_oNvfY6AnU5BxEsdDPOBfBP-uz_b0gAKBQ==.v=1.k=1.d=1498600993.t=a.l=.u=aaf9a833-ef30-4c22-86a0-9adc8a15b3b4.c=15037015562284012115',
        expires_in: 900,
        token_type: 'Bearer',
        user: 'aaf9a833-ef30-4c22-86a0-9adc8a15b3b4',
    };
    beforeEach(() => {
        nock(MOCK_BACKEND.rest)
            .post(auth_1.AuthAPI.URL.LOGIN, body => body.email && body.password)
            .query(() => true)
            .reply((uri, body) => {
            if (body.password === 'wrong') {
                return [
                    http_1.StatusCode.FORBIDDEN,
                    JSON.stringify({
                        code: http_1.StatusCode.FORBIDDEN,
                        label: 'invalid-credentials',
                        message: 'Authentication failed.',
                    }),
                ];
            }
            return [http_1.StatusCode.OK, JSON.stringify(accessTokenData)];
        });
        nock(MOCK_BACKEND.rest).post(`${auth_1.AuthAPI.URL.ACCESS}/${auth_1.AuthAPI.URL.LOGOUT}`).reply(http_1.StatusCode.OK, undefined);
        nock(MOCK_BACKEND.rest).post(auth_1.AuthAPI.URL.ACCESS).reply(http_1.StatusCode.OK, accessTokenData);
        nock(MOCK_BACKEND.rest).post(client_1.ClientAPI.URL.CLIENTS).reply(http_1.StatusCode.OK, { id: CLIENT_ID });
        nock(MOCK_BACKEND.rest)
            .post(new RegExp(`${conversation_1.ConversationAPI.URL.CONVERSATIONS}/.*/${conversation_1.ConversationAPI.URL.OTR}/${conversation_1.ConversationAPI.URL.MESSAGES}`))
            .query({ ignore_missing: false })
            .reply(http_1.StatusCode.OK)
            .persist();
        nock(MOCK_BACKEND.rest)
            .get(`${notification_1.NotificationAPI.URL.NOTIFICATION}/${notification_1.NotificationAPI.URL.LAST}`)
            .query({ client: CLIENT_ID })
            .reply(http_1.StatusCode.OK, {});
        nock(MOCK_BACKEND.rest)
            .get(notification_1.NotificationAPI.URL.NOTIFICATION)
            .query({ client: CLIENT_ID, size: 10000 })
            .reply(http_1.StatusCode.OK, { has_more: false, notifications: [] })
            .persist();
        nock(MOCK_BACKEND.rest)
            .get(client_1.ClientAPI.URL.CLIENTS)
            .reply(http_1.StatusCode.OK, [{ id: CLIENT_ID }]);
    });
    describe('"createText"', () => {
        it('creates a text payload', () => __awaiter(void 0, void 0, void 0, function* () {
            const account = yield createAccount();
            yield account.login({
                clientType: client_1.ClientType.TEMPORARY,
                email: 'hello@example.com',
                password: 'my-secret',
            });
            expect(account['apiClient'].context.userId).toBeDefined();
            const text = 'FIFA World Cup';
            const payload = account.service.conversation.messageBuilder.createText('', text).build();
            expect(payload.timestamp).toBeGreaterThan(0);
        }));
    });
    describe('"init"', () => {
        it('initializes the Protocol buffers', () => __awaiter(void 0, void 0, void 0, function* () {
            const account = new Account_1.Account();
            yield account.initServices(new store_engine_1.MemoryEngine());
            expect(account.service.conversation).toBeDefined();
            expect(account.service.cryptography).toBeDefined();
            const message = protocol_messaging_1.GenericMessage.create({
                messageId: '2d7cb6d8-118f-11e8-b642-0ed5f89f718b',
                text: protocol_messaging_1.Text.create({ content: 'Hello, World!' }),
            });
            expect(message.content).toBe('text');
        }));
    });
    describe('"login"', () => {
        it('logs in with correct credentials', () => __awaiter(void 0, void 0, void 0, function* () {
            const apiClient = new api_client_1.APIClient({ urls: MOCK_BACKEND });
            const account = new Account_1.Account(apiClient);
            yield account.initServices(new store_engine_1.MemoryEngine());
            const { clientId, clientType, userId } = (yield account.login({
                clientType: client_1.ClientType.TEMPORARY,
                email: 'hello@example.com',
                password: 'my-secret',
            }));
            expect(clientId).toBe(CLIENT_ID);
            expect(commons_1.ValidationUtil.isUUIDv4(userId)).toBe(true);
            expect(clientType).toBe(client_1.ClientType.TEMPORARY);
        }));
        it('does not log in with incorrect credentials', () => __awaiter(void 0, void 0, void 0, function* () {
            const apiClient = new api_client_1.APIClient({ urls: MOCK_BACKEND });
            const account = new Account_1.Account(apiClient);
            yield account.initServices(new store_engine_1.MemoryEngine());
            try {
                yield account.login({
                    clientType: client_1.ClientType.TEMPORARY,
                    email: 'hello@example.com',
                    password: 'wrong',
                });
                fail('Should not be logged in');
            }
            catch (error) {
                expect(error.code).toBe(http_1.StatusCode.FORBIDDEN);
                expect(error.label).toBe(http_1.BackendErrorLabel.INVALID_CREDENTIALS);
            }
        }));
    });
    it('emits text messages', (done) => __awaiter(void 0, void 0, void 0, function* () {
        const account = yield createAccount();
        yield account.login({
            clientType: client_1.ClientType.TEMPORARY,
            email: 'hello@example.com',
            password: 'my-secret',
        });
        yield account.listen();
        spyOn(account.service.notification, 'handleEvent').and.returnValue({ type: conversation_2.PayloadBundleType.TEXT });
        account.service.notification.on(conversation_2.PayloadBundleType.TEXT, message => {
            expect(message.type).toBe(conversation_2.PayloadBundleType.TEXT);
        });
        account.on(conversation_2.PayloadBundleType.TEXT, message => {
            expect(message.type).toBe(conversation_2.PayloadBundleType.TEXT);
            done();
        });
        yield account.service.notification.handleNotification({
            payload: [{}],
            transient: true,
        }, conversation_2.PayloadBundleSource.WEBSOCKET);
    }));
});
//# sourceMappingURL=Account.test.node.js.map