"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cryptobox_1 = require("@wireapp/cryptobox");
const proteus_1 = require("@wireapp/proteus");
const protocol_messaging_1 = require("@wireapp/protocol-messaging");
const bazinga64_1 = require("bazinga64");
const logdown_1 = __importDefault(require("logdown"));
const conversation_1 = require("../conversation");
const CryptographyDatabaseRepository_1 = require("./CryptographyDatabaseRepository");
const GenericMessageMapper_1 = require("./GenericMessageMapper");
class CryptographyService {
    constructor(apiClient, storeEngine) {
        this.apiClient = apiClient;
        this.storeEngine = storeEngine;
        this.cryptobox = new cryptobox_1.Cryptobox(this.storeEngine);
        this.database = new CryptographyDatabaseRepository_1.CryptographyDatabaseRepository(this.storeEngine);
        this.logger = logdown_1.default('@wireapp/core/cryptography/CryptographyService', {
            logger: console,
            markdown: false,
        });
    }
    static constructSessionId(userId, clientId) {
        return `${userId}@${clientId}`;
    }
    createCryptobox() {
        return __awaiter(this, void 0, void 0, function* () {
            const initialPreKeys = yield this.cryptobox.create();
            return initialPreKeys
                .map(preKey => {
                const preKeyJson = this.cryptobox.serialize_prekey(preKey);
                if (preKeyJson.id !== proteus_1.keys.PreKey.MAX_PREKEY_ID) {
                    return preKeyJson;
                }
                return { id: -1, key: '' };
            })
                .filter(serializedPreKey => serializedPreKey.key);
        });
    }
    decrypt(sessionId, encodedCiphertext) {
        this.logger.log(`Decrypting message for session ID "${sessionId}"`);
        const messageBytes = bazinga64_1.Decoder.fromBase64(encodedCiphertext).asBytes;
        return this.cryptobox.decrypt(sessionId, messageBytes.buffer);
    }
    static dismantleSessionId(sessionId) {
        return sessionId.split('@');
    }
    encrypt(plainText, preKeyBundles) {
        return __awaiter(this, void 0, void 0, function* () {
            const recipients = {};
            const encryptions = [];
            for (const userId in preKeyBundles) {
                recipients[userId] = {};
                for (const clientId in preKeyBundles[userId]) {
                    const preKeyPayload = preKeyBundles[userId][clientId];
                    const preKey = preKeyPayload.key;
                    const sessionId = CryptographyService.constructSessionId(userId, clientId);
                    encryptions.push(this.encryptPayloadForSession(sessionId, plainText, preKey));
                }
            }
            const payloads = yield Promise.all(encryptions);
            if (payloads) {
                payloads.forEach((payload) => {
                    const sessionId = payload.sessionId;
                    const encrypted = payload.encryptedPayload;
                    const [userId, clientId] = CryptographyService.dismantleSessionId(sessionId);
                    recipients[userId][clientId] = encrypted;
                });
            }
            return recipients;
        });
    }
    encryptPayloadForSession(sessionId, plainText, base64EncodedPreKey) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.log(`Encrypting Payload for session ID "${sessionId}"`);
            let encryptedPayload;
            try {
                const decodedPreKeyBundle = bazinga64_1.Decoder.fromBase64(base64EncodedPreKey).asBytes;
                const payloadAsBuffer = yield this.cryptobox.encrypt(sessionId, plainText, decodedPreKeyBundle.buffer);
                encryptedPayload = bazinga64_1.Encoder.toBase64(payloadAsBuffer).asString;
            }
            catch (error) {
                this.logger.error(`Could not encrypt payload: ${error.message}`);
                encryptedPayload = 'ðŸ’£';
            }
            return { encryptedPayload, sessionId };
        });
    }
    initCryptobox() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cryptobox.load();
        });
    }
    deleteCryptographyStores() {
        return this.database.deleteStores();
    }
    resetSession(sessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.cryptobox.session_delete(sessionId);
            this.logger.log(`Deleted session ID "${sessionId}".`);
        });
    }
    decodeGenericMessage(otrMessage, source) {
        return __awaiter(this, void 0, void 0, function* () {
            const { from, data: { sender, text: cipherText }, } = otrMessage;
            const sessionId = CryptographyService.constructSessionId(from, sender);
            const decryptedMessage = yield this.decrypt(sessionId, cipherText);
            const genericMessage = protocol_messaging_1.GenericMessage.decode(decryptedMessage);
            if (genericMessage.content === conversation_1.GenericMessageType.EPHEMERAL) {
                const unwrappedMessage = GenericMessageMapper_1.GenericMessageMapper.mapGenericMessage(genericMessage.ephemeral, otrMessage, source);
                unwrappedMessage.id = genericMessage.messageId;
                if (genericMessage.ephemeral) {
                    const expireAfterMillis = genericMessage.ephemeral.expireAfterMillis;
                    unwrappedMessage.messageTimer =
                        typeof expireAfterMillis === 'number' ? expireAfterMillis : expireAfterMillis.toNumber();
                }
                return unwrappedMessage;
            }
            return GenericMessageMapper_1.GenericMessageMapper.mapGenericMessage(genericMessage, otrMessage, source);
        });
    }
}
exports.CryptographyService = CryptographyService;
//# sourceMappingURL=CryptographyService.js.map