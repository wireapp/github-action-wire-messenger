"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
const api_client_1 = require("@wireapp/api-client");
const cryptobox_1 = require("@wireapp/cryptobox");
const Proteus = __importStar(require("@wireapp/proteus"));
const store_engine_1 = require("@wireapp/store-engine");
const bazinga64 = __importStar(require("bazinga64"));
const crypto = __importStar(require("crypto"));
const util_1 = require("util");
const CryptographyHelper = __importStar(require("../test/CryptographyHelper"));
const AssetCryptography_node_1 = require("./AssetCryptography.node");
const CryptographyService_1 = require("./CryptographyService");
function createEngine(storeName) {
    return __awaiter(this, void 0, void 0, function* () {
        const engine = new store_engine_1.MemoryEngine();
        yield engine.init(storeName);
        return engine;
    });
}
describe('CryptographyService', () => {
    let cryptographyService;
    let aliceLastResortPreKey;
    let bob;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        cryptographyService = new CryptographyService_1.CryptographyService(new api_client_1.APIClient(), yield createEngine('wire'));
        const preKeys = yield cryptographyService.cryptobox.create();
        aliceLastResortPreKey = preKeys.filter(preKey => preKey.key_id === Proteus.keys.PreKey.MAX_PREKEY_ID)[0];
        bob = new cryptobox_1.Cryptobox(yield createEngine('wire'));
        yield bob.create();
    }));
    describe('"constructor"', () => {
        it('creates an instance.', () => {
            expect(cryptographyService.cryptobox.identity.public_key.fingerprint()).toBeDefined();
            expect(cryptographyService).toBeDefined();
        });
    });
    describe('"constructSessionId"', () => {
        it('constructs a Session ID by a given User ID and Client ID.', () => {
            const clientId = '1ceb9063fced26d3';
            const userId = 'afbb5d60-1187-4385-9c29-7361dea79647';
            const actual = CryptographyService_1.CryptographyService.constructSessionId(userId, clientId);
            expect(actual).toContain(clientId);
            expect(actual).toContain(userId);
        });
    });
    describe('"decrypt"', () => {
        it('decrypts a Base64-encoded cipher message.', () => __awaiter(void 0, void 0, void 0, function* () {
            const alicePublicKey = cryptographyService.cryptobox.identity.public_key;
            const publicPreKeyBundle = new Proteus.keys.PreKeyBundle(alicePublicKey, aliceLastResortPreKey);
            const text = 'Hello Alice!';
            const encryptedPreKeyMessage = yield bob.encrypt('alice-user-id@alice-client-id', text, publicPreKeyBundle.serialise());
            const encodedPreKeyMessage = bazinga64.Encoder.toBase64(encryptedPreKeyMessage).asString;
            const decryptedMessage = yield cryptographyService.decrypt('bob-user-id@bob-client-id', encodedPreKeyMessage);
            const plaintext = Buffer.from(decryptedMessage).toString('utf8');
            expect(plaintext).toBe(text);
        }));
        it('is resistant to duplicated message errors', () => __awaiter(void 0, void 0, void 0, function* () {
            const receiver = cryptographyService.cryptobox.identity;
            const preKey = yield cryptographyService.cryptobox.get_prekey();
            const text = 'Hi!';
            const encodedPreKeyMessage = yield CryptographyHelper.createEncodedCipherText(receiver, preKey, text);
            const sessionId = 'alice-to-bob';
            const plaintext = yield CryptographyHelper.getPlainText(cryptographyService, encodedPreKeyMessage, sessionId);
            // Testing to decrypt the same message multiple times (to provoke duplicate message errors)
            yield CryptographyHelper.getPlainText(cryptographyService, encodedPreKeyMessage, sessionId);
            yield CryptographyHelper.getPlainText(cryptographyService, encodedPreKeyMessage, sessionId);
            yield CryptographyHelper.getPlainText(cryptographyService, encodedPreKeyMessage, sessionId);
            expect(plaintext).toBe(text);
        }));
    });
    describe('"dismantleSessionId"', () => {
        it('gets User ID and Client ID from a Session ID.', () => {
            const clientId = '1ceb9063fced26d3';
            const userId = 'afbb5d60-1187-4385-9c29-7361dea79647';
            const sessionId = CryptographyService_1.CryptographyService.constructSessionId(userId, clientId);
            const [actualUserId, actualClientId] = CryptographyService_1.CryptographyService['dismantleSessionId'](sessionId);
            expect(actualClientId).toBe(clientId);
            expect(actualUserId).toBe(userId);
        });
    });
    describe('"encrypt"', () => {
        it('generates a set of encrypted data based on PreKeys from multiple clients.', () => __awaiter(void 0, void 0, void 0, function* () {
            const firstUserID = 'bc0c99f1-49a5-4ad2-889a-62885af37088';
            const secondUserID = '2bde49aa-bdb5-458f-98cf-7d3552b10916';
            const firstClientId = '2b83ee08d7ac550d';
            const preKeyBundleMap = {
                [firstUserID]: {
                    '5e80ea7886680975': {
                        id: 1337,
                        key: 'pQABARn//wKhAFggJ1Fbpg5l6wnzKOJE+vXpRnkqUYhIvVnR5lNXEbO2o/0DoQChAFggHxZvgvtDktY/vqBcpjjo6rQnXvcNQhfwmy8AJQJKlD0E9g==',
                    },
                    be67218b77d02d30: {
                        id: 72,
                        key: 'pQABARn//wKhAFggTWwHUoppQ8aXWhbH95YWnNp6uOYMxo2y4wbarWbF+EEDoQChAFggUiFoPtsiR0WFowIvl0myD+bVnFQJBYarqieI0Gly46QE9g==',
                    },
                    [firstClientId]: {
                        id: 42,
                        key: 'pQABARn//wKhAFggWcbwny0jdqlcnnn0j4QSENIVVq/KgyQ3mmdpunfvGZQDoQChAFggrsQBkQkrVZ8sWhr8wTeaC+dmctuJ3oRqfdHsymTtKmgE9g==',
                    },
                },
                [secondUserID]: {
                    '5bad8cdeddc5a90f': {
                        id: 1,
                        key: 'pQABARn//wKhAFggEYATUNJBQ7E2tfHT7HMLxa4O3Ckd7PciUdyKiGNNWbYDoQChAFggP/s0BHmHQDNwrO4pC1dqdNHsW7bnpmF9mBadrbep4PoE9g==',
                    },
                    bc78eded90386d20: {
                        id: 65535,
                        key: 'pQABARn//wKhAFgg1xOfzMpWmpN2aBGW+0RG23L0I301pncd/HXqUm+pVyoDoQChAFggnl+dmwGW45AArcPutjUkAjYmhIbXBPrqkVrNyg0ZI08E9g==',
                    },
                },
            };
            const text = new Uint8Array([72, 101, 108, 108, 111, 33]); // "Hello!"
            const otrBundle = yield cryptographyService.encrypt(text, preKeyBundleMap);
            expect(Object.keys(otrBundle).length).toBe(2);
            expect(Object.keys(otrBundle[firstUserID]).length).toBe(3);
            expect(Object.keys(otrBundle[secondUserID]).length).toBe(2);
            expect(otrBundle[firstUserID][firstClientId]).toEqual(jasmine.any(String));
        }));
        it('does not generate a message counter twice when ran asynchronously multiple times for the same cryptographic session', () => __awaiter(void 0, void 0, void 0, function* () {
            const userId = 'bc0c99f1-49a5-4ad2-889a-62885af37088';
            const clientId = '5e80ea7886680975';
            const preKeyBundleMap = {
                [userId]: {
                    [clientId]: {
                        id: 1337,
                        key: 'pQABARn//wKhAFggJ1Fbpg5l6wnzKOJE+vXpRnkqUYhIvVnR5lNXEbO2o/0DoQChAFggHxZvgvtDktY/vqBcpjjo6rQnXvcNQhfwmy8AJQJKlD0E9g==',
                    },
                },
            };
            const text = new Uint8Array([72, 101, 108, 108, 111, 33]); // "Hello!"
            const encryptionRuns = 100;
            const otrBundles = yield Promise.all(Array.from(Array(encryptionRuns).keys()).map(() => cryptographyService.encrypt(text, preKeyBundleMap)));
            const encryptedPayloads = otrBundles.map(bundle => bundle[userId][clientId]);
            const messageCounters = encryptedPayloads.map(encodedCiphertext => {
                const messageBytes = bazinga64.Decoder.fromBase64(encodedCiphertext).asBytes;
                const messageEnvelope = Proteus.message.Envelope.deserialise(messageBytes.buffer);
                const preKeyMessage = messageEnvelope.message;
                const cipherMessage = preKeyMessage.message;
                return cipherMessage.counter;
            });
            const uniqueValues = messageCounters.filter((value, index, self) => self.indexOf(value) === index);
            expect(uniqueValues.length).toBe(encryptionRuns);
        }));
    });
    describe('"encryptAsset"', () => {
        it('encrypts and decrypts ArrayBuffer', () => __awaiter(void 0, void 0, void 0, function* () {
            const bytes = new Uint8Array(16);
            yield util_1.promisify(crypto.randomFill)(bytes);
            const byteBuffer = Buffer.from(bytes.buffer);
            const encryptedAsset = yield AssetCryptography_node_1.encryptAsset(byteBuffer);
            const decryptedBuffer = yield AssetCryptography_node_1.decryptAsset(encryptedAsset);
            expect(decryptedBuffer).toEqual(byteBuffer);
        }));
    });
    describe('"encryptPayloadForSession"', () => {
        it('encodes plaintext.', () => __awaiter(void 0, void 0, void 0, function* () {
            const sessionWithBobId = 'bob-user-id@bob-client-id';
            const text = new Uint8Array([72, 101, 108, 108, 111, 32, 66, 111, 98, 33]); // "Hello Bob!"
            const encodedPreKey = 'pQABAQACoQBYIHOFFWPnWlr4sulxUWYoP0A6rsJiBO/Ec3Y914t67CIAA6EAoQBYIPFH5CK/a0YwKEx4n/+U/IPRN+mJXVv++MCs5Z4dLmz4BPY=';
            const { sessionId, encryptedPayload } = yield cryptographyService['encryptPayloadForSession'](sessionWithBobId, text, encodedPreKey);
            expect(encryptedPayload).not.toBe('💣');
            expect(sessionId).toBe(sessionWithBobId);
        }));
        it('encodes invalid text as Bomb Emoji.', () => __awaiter(void 0, void 0, void 0, function* () {
            const sessionWithBobId = 'bob-user-id@bob-client-id';
            const encodedPreKey = 'pQABAQACoQBYIHOFFWPnWlr4sulxUWYoP0A6rsJiBO/Ec3Y914t67CIAA6EAoQBYIPFH5CK/a0YwKEx4n/+U/IPRN+mJXVv++MCs5Z4dLmz4BPY=';
            const { sessionId, encryptedPayload } = yield cryptographyService['encryptPayloadForSession'](sessionWithBobId, undefined, encodedPreKey);
            expect(encryptedPayload).toBe('💣');
            expect(sessionId).toBe(sessionWithBobId);
        }));
    });
});
//# sourceMappingURL=CryptographyService.test.node.js.map