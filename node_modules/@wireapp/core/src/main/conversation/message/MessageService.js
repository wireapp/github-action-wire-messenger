"use strict";
/*
 * Wire
 * Copyright (C) 2020 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageService = void 0;
const http_status_codes_1 = require("http-status-codes");
const otr_1 = require("@wireapp/protocol-messaging/web/otr");
const long_1 = __importDefault(require("long"));
const StringUtil_1 = require("@wireapp/commons/src/main/util/StringUtil");
const bazinga64_1 = require("bazinga64");
const cryptography_1 = require("../../cryptography");
class MessageService {
    constructor(apiClient, cryptographyService) {
        this.apiClient = apiClient;
        this.cryptographyService = cryptographyService;
    }
    async sendOTRMessage(sendingClientId, recipients, conversationId, plainTextArray, base64CipherText) {
        const message = {
            data: base64CipherText,
            recipients: cryptography_1.CryptographyService.convertArrayRecipientsToBase64(recipients),
            sender: sendingClientId,
        };
        /*
         * When creating the PreKey bundles we already found out to which users we want to send a message, so we can ignore
         * missing clients. We have to ignore missing clients because there can be the case that there are clients that
         * don't provide PreKeys (clients from the Pre-E2EE era).
         */
        const ignoreMissing = true;
        try {
            if (conversationId === null) {
                return await this.apiClient.broadcast.api.postBroadcastMessage(sendingClientId, message, ignoreMissing);
            }
            return await this.apiClient.conversation.api.postOTRMessage(sendingClientId, conversationId, message, ignoreMissing);
        }
        catch (error) {
            const reEncryptedMessage = await this.onClientMismatch(error, Object.assign(Object.assign({}, message), { data: base64CipherText ? bazinga64_1.Decoder.fromBase64(base64CipherText).asBytes : undefined, recipients }), plainTextArray);
            return await this.apiClient.broadcast.api.postBroadcastMessage(sendingClientId, {
                data: reEncryptedMessage.data ? bazinga64_1.Encoder.toBase64(reEncryptedMessage.data).asString : undefined,
                recipients: cryptography_1.CryptographyService.convertArrayRecipientsToBase64(reEncryptedMessage.recipients),
                sender: reEncryptedMessage.sender,
            });
        }
    }
    checkFederatedClientsMismatch(messageData, messageSendingStatus) {
        var _a, _b, _c, _d;
        const updatedMessageSendingStatus = Object.assign({}, messageSendingStatus);
        const sendingStatusKeys = [
            'deleted',
            'failed_to_send',
            'missing',
            'redundant',
        ];
        if ((_b = (_a = messageData.ignoreOnly) === null || _a === void 0 ? void 0 : _a.userIds) === null || _b === void 0 ? void 0 : _b.length) {
            const allFailed = Object.assign(Object.assign(Object.assign(Object.assign({}, messageSendingStatus.deleted), messageSendingStatus.failed_to_send), messageSendingStatus.missing), messageSendingStatus.redundant);
            for (const [domainFailed, userClientsFailed] of Object.entries(allFailed)) {
                for (const userIdMissing of Object.keys(userClientsFailed)) {
                    const userIsIgnored = messageData.ignoreOnly.userIds.find(({ domain: domainIgnore, id: userIdIgnore }) => {
                        return userIdIgnore === userIdMissing && domainIgnore === domainFailed;
                    });
                    if (userIsIgnored) {
                        for (const sendingStatusKey of sendingStatusKeys) {
                            delete updatedMessageSendingStatus[sendingStatusKey][domainFailed][userIdMissing];
                        }
                    }
                }
            }
        }
        else if ((_d = (_c = messageData.reportOnly) === null || _c === void 0 ? void 0 : _c.userIds) === null || _d === void 0 ? void 0 : _d.length) {
            for (const [reportDomain, reportUserId] of Object.entries(messageData.reportOnly.userIds)) {
                for (const sendingStatusKey of sendingStatusKeys) {
                    for (const [domainDeleted, userClientsDeleted] of Object.entries(updatedMessageSendingStatus[sendingStatusKey])) {
                        for (const userIdDeleted of Object.keys(userClientsDeleted)) {
                            if (userIdDeleted !== reportUserId.id && domainDeleted !== reportDomain) {
                                delete updatedMessageSendingStatus[sendingStatusKey][domainDeleted][userIdDeleted];
                            }
                        }
                    }
                }
            }
        }
        else if (!!messageData.ignoreAll) {
            // report nothing
            return null;
        }
        return updatedMessageSendingStatus;
    }
    async sendFederatedOTRMessage(sendingClientId, conversationId, conversationDomain, recipients, plainTextArray, assetData) {
        const qualifiedUserEntries = Object.entries(recipients).map(([domain, otrRecipients]) => {
            const userEntries = Object.entries(otrRecipients).map(([userId, otrClientMap]) => {
                const clientEntries = Object.entries(otrClientMap).map(([clientId, payload]) => {
                    return {
                        client: {
                            client: long_1.default.fromString(clientId, 16),
                        },
                        text: payload,
                    };
                });
                return {
                    user: {
                        uuid: (0, StringUtil_1.uuidToBytes)(userId),
                    },
                    clients: clientEntries,
                };
            });
            return { domain, entries: userEntries };
        });
        const protoMessage = otr_1.proteus.QualifiedNewOtrMessage.create({
            recipients: qualifiedUserEntries,
            sender: {
                client: long_1.default.fromString(sendingClientId, 16),
            },
        });
        if (assetData) {
            protoMessage.blob = assetData;
        }
        /*
         * When creating the PreKey bundles we already found out to which users we want to send a message, so we can ignore
         * missing clients. We have to ignore missing clients because there can be the case that there are clients that
         * don't provide PreKeys (clients from the Pre-E2EE era).
         */
        protoMessage.ignoreAll = {};
        const messageSendingStatus = await this.apiClient.conversation.api.postOTRMessageV2(conversationId, conversationDomain, protoMessage);
        const federatedClientsMismatch = this.checkFederatedClientsMismatch(protoMessage, messageSendingStatus);
        if (federatedClientsMismatch) {
            const reEncryptedMessage = await this.onFederatedClientMismatch(protoMessage, federatedClientsMismatch, plainTextArray);
            await this.apiClient.conversation.api.postOTRMessageV2(conversationId, conversationDomain, reEncryptedMessage);
        }
        return messageSendingStatus;
    }
    async sendOTRProtobufMessage(sendingClientId, recipients, conversationId, plainTextArray, assetData) {
        const userEntries = Object.entries(recipients).map(([userId, otrClientMap]) => {
            const clients = Object.entries(otrClientMap).map(([clientId, payload]) => {
                return {
                    client: {
                        client: long_1.default.fromString(clientId, 16),
                    },
                    text: payload,
                };
            });
            return {
                clients,
                user: {
                    uuid: (0, StringUtil_1.uuidToBytes)(userId),
                },
            };
        });
        const protoMessage = otr_1.proteus.NewOtrMessage.create({
            recipients: userEntries,
            sender: {
                client: long_1.default.fromString(sendingClientId, 16),
            },
        });
        if (assetData) {
            protoMessage.blob = assetData;
        }
        /*
         * When creating the PreKey bundles we already found out to which users we want to send a message, so we can ignore
         * missing clients. We have to ignore missing clients because there can be the case that there are clients that
         * don't provide PreKeys (clients from the Pre-E2EE era).
         */
        const ignoreMissing = true;
        try {
            if (conversationId === null) {
                return await this.apiClient.broadcast.api.postBroadcastProtobufMessage(sendingClientId, protoMessage, ignoreMissing);
            }
            return await this.apiClient.conversation.api.postOTRProtobufMessage(sendingClientId, conversationId, protoMessage, ignoreMissing);
        }
        catch (error) {
            const reEncryptedMessage = await this.onClientProtobufMismatch(error, protoMessage, plainTextArray);
            if (conversationId === null) {
                return await this.apiClient.broadcast.api.postBroadcastProtobufMessage(sendingClientId, reEncryptedMessage);
            }
            return await this.apiClient.conversation.api.postOTRProtobufMessage(sendingClientId, conversationId, reEncryptedMessage, ignoreMissing);
        }
    }
    async onClientMismatch(error, message, plainTextArray) {
        var _a, _b;
        if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === http_status_codes_1.StatusCodes.PRECONDITION_FAILED) {
            const { missing, deleted } = (_b = error.response) === null || _b === void 0 ? void 0 : _b.data;
            const deletedUserIds = Object.keys(deleted);
            const missingUserIds = Object.keys(missing);
            if (deletedUserIds.length) {
                for (const deletedUserId of deletedUserIds) {
                    for (const deletedClientId of deleted[deletedUserId]) {
                        const deletedUser = message.recipients[deletedUserId];
                        if (deletedUser) {
                            delete deletedUser[deletedClientId];
                        }
                    }
                }
            }
            if (missingUserIds.length) {
                const missingPreKeyBundles = await this.apiClient.user.api.postMultiPreKeyBundles(missing);
                const reEncryptedPayloads = await this.cryptographyService.encrypt(plainTextArray, missingPreKeyBundles);
                for (const missingUserId of missingUserIds) {
                    for (const missingClientId in reEncryptedPayloads[missingUserId]) {
                        const missingUser = message.recipients[missingUserId];
                        if (!missingUser) {
                            message.recipients[missingUserId] = {};
                        }
                        message.recipients[missingUserId][missingClientId] = reEncryptedPayloads[missingUserId][missingClientId];
                    }
                }
            }
            return message;
        }
        throw error;
    }
    async onClientProtobufMismatch(error, message, plainTextArray) {
        var _a, _b, _c, _d;
        if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === http_status_codes_1.StatusCodes.PRECONDITION_FAILED) {
            const { missing, deleted } = (_b = error.response) === null || _b === void 0 ? void 0 : _b.data;
            const deletedUserIds = Object.keys(deleted);
            const missingUserIds = Object.keys(missing);
            if (deletedUserIds.length) {
                for (const deletedUserId of deletedUserIds) {
                    for (const deletedClientId of deleted[deletedUserId]) {
                        const deletedUserIndex = message.recipients.findIndex(({ user }) => (0, StringUtil_1.bytesToUUID)(user.uuid) === deletedUserId);
                        if (deletedUserIndex > -1) {
                            const deletedClientIndex = (_c = message.recipients[deletedUserIndex].clients) === null || _c === void 0 ? void 0 : _c.findIndex(({ client }) => {
                                return client.client.toString(16) === deletedClientId;
                            });
                            if (typeof deletedClientIndex !== 'undefined' && deletedClientIndex > -1) {
                                (_d = message.recipients[deletedUserIndex].clients) === null || _d === void 0 ? true : delete _d[deletedClientIndex];
                            }
                        }
                    }
                }
            }
            if (missingUserIds.length) {
                const missingPreKeyBundles = await this.apiClient.user.api.postMultiPreKeyBundles(missing);
                const reEncryptedPayloads = await this.cryptographyService.encrypt(plainTextArray, missingPreKeyBundles);
                for (const missingUserId of missingUserIds) {
                    for (const missingClientId in reEncryptedPayloads[missingUserId]) {
                        const missingUserIndex = message.recipients.findIndex(({ user }) => (0, StringUtil_1.bytesToUUID)(user.uuid) === missingUserId);
                        if (missingUserIndex === -1) {
                            message.recipients.push({
                                clients: [
                                    {
                                        client: {
                                            client: long_1.default.fromString(missingClientId, 16),
                                        },
                                        text: reEncryptedPayloads[missingUserId][missingClientId],
                                    },
                                ],
                                user: {
                                    uuid: (0, StringUtil_1.uuidToBytes)(missingUserId),
                                },
                            });
                        }
                    }
                }
            }
            return message;
        }
        throw error;
    }
    async onFederatedClientMismatch(messageData, messageSendingStatus, plainTextArray) {
        var _a, _b, _c;
        var _d;
        // walk through deleted domain/user map
        for (const [deletedUserDomain, deletedUserIdClients] of Object.entries(messageSendingStatus.deleted)) {
            if (!messageData.recipients.find(recipient => recipient.domain === deletedUserDomain)) {
                // no user from this domain was deleted
                continue;
            }
            // walk through deleted user ids
            for (const [deletedUserId] of Object.entries(deletedUserIdClients)) {
                // walk through message recipients
                for (const recipientIndex in messageData.recipients) {
                    // check if message recipients' domain is the same as the deleted user's domain
                    if (messageData.recipients[recipientIndex].domain === deletedUserDomain) {
                        // check if message recipients' id is the same as the deleted user's id
                        for (const entriesIndex in messageData.recipients[recipientIndex].entries || []) {
                            const uuid = (_a = messageData.recipients[recipientIndex].entries[entriesIndex].user) === null || _a === void 0 ? void 0 : _a.uuid;
                            if (!!uuid && (0, StringUtil_1.bytesToUUID)(uuid) === deletedUserId) {
                                // delete this user from the message recipients
                                delete messageData.recipients[recipientIndex].entries[entriesIndex];
                            }
                        }
                    }
                }
            }
        }
        const missingUserIds = Object.entries(messageSendingStatus.missing);
        if (missingUserIds.length) {
            const missingPreKeyBundles = await this.apiClient.user.api.postQualifiedMultiPreKeyBundles(messageSendingStatus.missing);
            const reEncryptedPayloads = await this.cryptographyService.encryptQualified(plainTextArray, missingPreKeyBundles);
            // walk through missing domain/user map
            for (const [missingUserDomain, missingUserIdClients] of missingUserIds) {
                if (!messageData.recipients.find(recipient => recipient.domain === missingUserDomain)) {
                    // no user from this domain is missing
                    continue;
                }
                // walk through missing user ids
                for (const [missingUserId, missingClientIds] of Object.entries(missingUserIdClients)) {
                    // walk through message recipients
                    for (const recipientIndex in messageData.recipients) {
                        // check if message recipients' domain is the same as the missing user's domain
                        if (messageData.recipients[recipientIndex].domain === missingUserDomain) {
                            // check if there is a recipient with same user id as the missing user's id
                            let userIndex = (_b = messageData.recipients[recipientIndex].entries) === null || _b === void 0 ? void 0 : _b.findIndex(({ user }) => (0, StringUtil_1.bytesToUUID)(user.uuid) === missingUserId);
                            if (userIndex === -1) {
                                // no recipient found, let's create it
                                userIndex = messageData.recipients[recipientIndex].entries.push({
                                    user: {
                                        uuid: (0, StringUtil_1.uuidToBytes)(missingUserId),
                                    },
                                });
                            }
                            const missingUserUUID = messageData.recipients[recipientIndex].entries[userIndex].user.uuid;
                            if ((0, StringUtil_1.bytesToUUID)(missingUserUUID) === missingUserId) {
                                for (const missingClientId of missingClientIds) {
                                    (_d = messageData.recipients[recipientIndex].entries[userIndex]).clients || (_d.clients = []);
                                    (_c = messageData.recipients[recipientIndex].entries[userIndex].clients) === null || _c === void 0 ? void 0 : _c.push({
                                        client: {
                                            client: long_1.default.fromString(missingClientId, 16),
                                        },
                                        text: reEncryptedPayloads[missingUserDomain][missingUserId][missingClientId],
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        return messageData;
    }
}
exports.MessageService = MessageService;
//# sourceMappingURL=MessageService.js.map