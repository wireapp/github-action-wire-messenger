"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationService = void 0;
const conversation_1 = require("@wireapp/api-client/src/conversation/");
const data_1 = require("@wireapp/api-client/src/conversation/data/");
const protocol_messaging_1 = require("@wireapp/protocol-messaging");
const bazinga64_1 = require("bazinga64");
const conversation_2 = require("../conversation/");
const AssetCryptography = __importStar(require("../cryptography/AssetCryptography.node"));
const TypePredicateUtil_1 = require("../util/TypePredicateUtil");
const MessageBuilder_1 = require("./message/MessageBuilder");
const MessageService_1 = require("./message/MessageService");
const MessageToProtoMapper_1 = require("./message/MessageToProtoMapper");
class ConversationService {
    constructor(apiClient, cryptographyService, assetService) {
        this.apiClient = apiClient;
        this.cryptographyService = cryptographyService;
        this.assetService = assetService;
        this.messageTimer = new conversation_2.MessageTimer();
        this.messageBuilder = new MessageBuilder_1.MessageBuilder(this.apiClient, this.assetService);
        this.messageService = new MessageService_1.MessageService(this.apiClient, this.cryptographyService);
    }
    createEphemeral(originalGenericMessage, expireAfterMillis) {
        const ephemeralMessage = protocol_messaging_1.Ephemeral.create({
            expireAfterMillis,
            [originalGenericMessage.content]: originalGenericMessage[originalGenericMessage.content],
        });
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.EPHEMERAL]: ephemeralMessage,
            messageId: originalGenericMessage.messageId,
        });
        return genericMessage;
    }
    async getQualifiedPreKeyBundle(conversationId, conversationDomain, userIds) {
        let members = [];
        if (userIds) {
            if ((0, TypePredicateUtil_1.isQualifiedIdArray)(userIds)) {
                members = userIds;
            }
            else {
                members = Object.entries(userIds).reduce((accumulator, [domain, userClients]) => {
                    accumulator.push(...Object.keys(userClients).map(userId => ({ domain, id: userId })));
                    return accumulator;
                }, []);
            }
        }
        if (!members.length) {
            const conversation = await this.apiClient.conversation.api.getConversation(conversationId, conversationDomain);
            /*
             * If you are sending a message to a conversation, you have to include
             * yourself in the list of users if you want to sync a message also to your
             * other clients.
             */
            members = conversation.members.others
                .filter(member => !!member.qualified_id)
                .map(member => member.qualified_id)
                // TODO(Federation): Use 'domain' from 'conversation.members.self' when backend has it implemented
                .concat({ domain: this.apiClient.context.domain, id: conversation.members.self.id });
        }
        const preKeys = await Promise.all(members.map(async (qualifiedUserId) => {
            const prekeyBundle = await this.apiClient.user.api.getUserPreKeys(qualifiedUserId);
            return { user: qualifiedUserId, clients: prekeyBundle.clients };
        }));
        return preKeys.reduce((bundleMap, qualifiedPrekey) => {
            var _a, _b, _c;
            bundleMap[_a = qualifiedPrekey.user.domain] || (bundleMap[_a] = {});
            for (const client of qualifiedPrekey.clients) {
                (_b = bundleMap[qualifiedPrekey.user.domain])[_c = qualifiedPrekey.user.id] || (_b[_c] = {});
                bundleMap[qualifiedPrekey.user.domain][qualifiedPrekey.user.id][client.client] = client.prekey;
            }
            return bundleMap;
        }, {});
    }
    async getPreKeyBundleMap(conversationId, userIds) {
        let members = [];
        if (userIds) {
            if ((0, TypePredicateUtil_1.isStringArray)(userIds)) {
                members = userIds;
            }
            else if ((0, TypePredicateUtil_1.isUserClients)(userIds)) {
                members = Object.keys(userIds);
            }
        }
        if (!members.length) {
            const conversation = await this.apiClient.conversation.api.getConversation(conversationId);
            /*
             * If you are sending a message to a conversation, you have to include
             * yourself in the list of users if you want to sync a message also to your
             * other clients.
             */
            members = conversation.members.others.map(member => member.id).concat(conversation.members.self.id);
        }
        const preKeys = await Promise.all(members.map(member => this.apiClient.user.api.getUserPreKeys(member)));
        return preKeys.reduce((bundleMap, bundle) => {
            const userId = bundle.user;
            bundleMap[userId] || (bundleMap[userId] = {});
            for (const client of bundle.clients) {
                bundleMap[userId][client.client] = client.prekey;
            }
            return bundleMap;
        }, {});
    }
    getSelfConversation() {
        const { userId } = this.apiClient.context;
        return this.apiClient.conversation.api.getConversation(userId);
    }
    async sendExternalGenericMessage(sendingClientId, conversationId, asset, preKeyBundles, sendAsProtobuf) {
        if (preKeyBundles.none) {
            const { cipherText, keyBytes, sha256 } = asset;
            const messageId = MessageBuilder_1.MessageBuilder.createId();
            const externalMessage = {
                otrKey: new Uint8Array(keyBytes),
                sha256: new Uint8Array(sha256),
            };
            const base64CipherText = bazinga64_1.Encoder.toBase64(cipherText).asString;
            const genericMessage = protocol_messaging_1.GenericMessage.create({
                [conversation_2.GenericMessageType.EXTERNAL]: externalMessage,
                messageId,
            });
            const plainTextArray = protocol_messaging_1.GenericMessage.encode(genericMessage).finish();
            const recipients = await this.cryptographyService.encrypt(plainTextArray, preKeyBundles);
            if (sendAsProtobuf) {
                return this.messageService.sendOTRProtobufMessage(sendingClientId, recipients, conversationId, plainTextArray, cipherText);
            }
            return this.messageService.sendOTRMessage(sendingClientId, recipients, conversationId, plainTextArray, base64CipherText);
            // todo: add federated sending here
        }
        return undefined;
    }
    async sendFederatedGenericMessage(sendingClientId, conversationId, conversationDomain, genericMessage, userIds) {
        const plainTextArray = protocol_messaging_1.GenericMessage.encode(genericMessage).finish();
        const preKeyBundles = await this.getQualifiedPreKeyBundle(conversationId, conversationDomain, userIds);
        const recipients = await this.cryptographyService.encryptQualified(plainTextArray, preKeyBundles);
        return this.messageService.sendFederatedOTRMessage(sendingClientId, conversationId, conversationDomain, recipients, plainTextArray);
    }
    async sendGenericMessage(sendingClientId, conversationId, genericMessage, userIds, sendAsProtobuf, conversationDomain) {
        if (conversationDomain) {
            if ((0, TypePredicateUtil_1.isStringArray)(userIds) || (0, TypePredicateUtil_1.isUserClients)(userIds)) {
                throw new Error('Invalid userIds option for sending');
            }
            return this.sendFederatedGenericMessage(this.apiClient.validatedClientId, conversationId, conversationDomain, genericMessage, userIds);
        }
        if ((0, TypePredicateUtil_1.isQualifiedIdArray)(userIds) || (0, TypePredicateUtil_1.isQualifiedUserClients)(userIds)) {
            throw new Error('Invalid userIds option for sending');
        }
        const plainTextArray = protocol_messaging_1.GenericMessage.encode(genericMessage).finish();
        const preKeyBundles = await this.getPreKeyBundleMap(conversationId, userIds);
        if (this.shouldSendAsExternal(plainTextArray, preKeyBundles)) {
            const encryptedAsset = await AssetCryptography.encryptAsset({ plainText: plainTextArray });
            return this.sendExternalGenericMessage(this.apiClient.validatedClientId, conversationId, encryptedAsset, preKeyBundles, sendAsProtobuf);
        }
        const recipients = await this.cryptographyService.encrypt(plainTextArray, preKeyBundles);
        return sendAsProtobuf
            ? this.messageService.sendOTRProtobufMessage(sendingClientId, recipients, conversationId, plainTextArray)
            : this.messageService.sendOTRMessage(sendingClientId, recipients, conversationId, plainTextArray);
    }
    async sendButtonAction(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.BUTTON_ACTION]: protocol_messaging_1.ButtonAction.create(payloadBundle.content),
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendButtonActionConfirmation(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.BUTTON_ACTION_CONFIRMATION]: protocol_messaging_1.ButtonActionConfirmation.create(payloadBundle.content),
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendComposite(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.COMPOSITE]: protocol_messaging_1.Composite.create(payloadBundle.content),
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendConfirmation(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const content = protocol_messaging_1.Confirmation.create(payloadBundle.content);
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.CONFIRMATION]: content,
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendEditedText(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const editedMessage = protocol_messaging_1.MessageEdit.create({
            replacingMessageId: payloadBundle.content.originalMessageId,
            text: MessageToProtoMapper_1.MessageToProtoMapper.mapText(payloadBundle),
        });
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.EDITED]: editedMessage,
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendFileData(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        if (!payloadBundle.content) {
            throw new Error('No content for sendFileData provided.');
        }
        const { asset, expectsReadConfirmation, legalHoldStatus } = payloadBundle.content;
        const remoteData = protocol_messaging_1.Asset.RemoteData.create({
            assetId: asset.key,
            assetToken: asset.token,
            otrKey: asset.keyBytes,
            sha256: asset.sha256,
        });
        const assetMessage = protocol_messaging_1.Asset.create({
            expectsReadConfirmation,
            legalHoldStatus,
            uploaded: remoteData,
        });
        assetMessage.status = conversation_2.AssetTransferState.UPLOADED;
        let genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.ASSET]: assetMessage,
            messageId: payloadBundle.id,
        });
        const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
        if (expireAfterMillis > 0) {
            genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
        }
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendFileMetaData(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        if (!payloadBundle.content) {
            throw new Error('No content for sendFileMetaData provided.');
        }
        const { expectsReadConfirmation, legalHoldStatus, metaData } = payloadBundle.content;
        const original = protocol_messaging_1.Asset.Original.create({
            audio: metaData.audio,
            mimeType: metaData.type,
            name: metaData.name,
            size: metaData.length,
            video: metaData.video,
        });
        const assetMessage = protocol_messaging_1.Asset.create({
            expectsReadConfirmation,
            legalHoldStatus,
            original,
        });
        let genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.ASSET]: assetMessage,
            messageId: payloadBundle.id,
        });
        const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
        if (expireAfterMillis > 0) {
            genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
        }
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendFileAbort(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        if (!payloadBundle.content) {
            throw new Error('No content for sendFileAbort provided.');
        }
        const { expectsReadConfirmation, legalHoldStatus, reason } = payloadBundle.content;
        const assetMessage = protocol_messaging_1.Asset.create({
            expectsReadConfirmation,
            legalHoldStatus,
            notUploaded: reason,
        });
        assetMessage.status = conversation_2.AssetTransferState.NOT_UPLOADED;
        let genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.ASSET]: assetMessage,
            messageId: payloadBundle.id,
        });
        const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
        if (expireAfterMillis > 0) {
            genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
        }
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendImage(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        if (!payloadBundle.content) {
            throw new Error('No content for sendImage provided.');
        }
        const { asset, expectsReadConfirmation, image, legalHoldStatus } = payloadBundle.content;
        const imageMetadata = protocol_messaging_1.Asset.ImageMetaData.create({
            height: image.height,
            width: image.width,
        });
        const original = protocol_messaging_1.Asset.Original.create({
            [conversation_2.GenericMessageType.IMAGE]: imageMetadata,
            mimeType: image.type,
            name: null,
            size: image.data.length,
        });
        const remoteData = protocol_messaging_1.Asset.RemoteData.create({
            assetId: asset.key,
            assetToken: asset.token,
            otrKey: asset.keyBytes,
            sha256: asset.sha256,
        });
        const assetMessage = protocol_messaging_1.Asset.create({
            expectsReadConfirmation,
            legalHoldStatus,
            original,
            uploaded: remoteData,
        });
        assetMessage.status = conversation_2.AssetTransferState.UPLOADED;
        let genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.ASSET]: assetMessage,
            messageId: payloadBundle.id,
        });
        const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
        if (expireAfterMillis > 0) {
            genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
        }
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { content: assetMessage, messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendLocation(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const { expectsReadConfirmation, latitude, legalHoldStatus, longitude, name, zoom } = payloadBundle.content;
        const locationMessage = protocol_messaging_1.Location.create({
            expectsReadConfirmation,
            latitude,
            legalHoldStatus,
            longitude,
            name,
            zoom,
        });
        let genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.LOCATION]: locationMessage,
            messageId: payloadBundle.id,
        });
        const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
        if (expireAfterMillis > 0) {
            genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
        }
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendKnock(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const content = protocol_messaging_1.Knock.create(payloadBundle.content);
        let genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.KNOCK]: content,
            messageId: payloadBundle.id,
        });
        const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
        if (expireAfterMillis > 0) {
            genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
        }
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { conversation: payloadBundle.conversation, messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendReaction(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const { legalHoldStatus, originalMessageId, type } = payloadBundle.content;
        const reaction = protocol_messaging_1.Reaction.create({
            emoji: type,
            legalHoldStatus,
            messageId: originalMessageId,
        });
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.REACTION]: reaction,
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendSessionReset(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.CLIENT_ACTION]: protocol_messaging_1.ClientAction.RESET_SESSION,
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendCall(payloadBundle, userIds, sendAsProtobuf, conversationDomain) {
        const callMessage = protocol_messaging_1.Calling.create({
            content: payloadBundle.content,
        });
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.CALLING]: callMessage,
            messageId: payloadBundle.id,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: 0, state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async sendText(payloadBundle, userIds, sendAsProtobuf, conversationDomain, callbacks) {
        var _a, _b;
        let genericMessage = protocol_messaging_1.GenericMessage.create({
            messageId: payloadBundle.id,
            [conversation_2.GenericMessageType.TEXT]: MessageToProtoMapper_1.MessageToProtoMapper.mapText(payloadBundle),
        });
        const expireAfterMillis = this.messageTimer.getMessageTimer(payloadBundle.conversation);
        if (expireAfterMillis > 0) {
            genericMessage = this.createEphemeral(genericMessage, expireAfterMillis);
        }
        (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onStart) === null || _a === void 0 ? void 0 : _a.call(callbacks, genericMessage);
        const response = await this.sendGenericMessage(this.apiClient.validatedClientId, payloadBundle.conversation, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onSuccess) === null || _b === void 0 ? void 0 : _b.call(callbacks, genericMessage, response === null || response === void 0 ? void 0 : response.time);
        return Object.assign(Object.assign({}, payloadBundle), { messageTimer: this.messageTimer.getMessageTimer(payloadBundle.conversation), state: conversation_2.PayloadBundleState.OUTGOING_SENT });
    }
    async clearConversation(conversationId, timestamp = new Date(), messageId = MessageBuilder_1.MessageBuilder.createId(), sendAsProtobuf, conversationDomain) {
        if (timestamp instanceof Date) {
            timestamp = timestamp.getTime();
        }
        const content = {
            clearedTimestamp: timestamp,
            conversationId,
        };
        const clearedMessage = protocol_messaging_1.Cleared.create(content);
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.CLEARED]: clearedMessage,
            messageId,
        });
        const { id: selfConversationId } = await this.getSelfConversation();
        await this.sendGenericMessage(this.apiClient.validatedClientId, selfConversationId, genericMessage, undefined, sendAsProtobuf, conversationDomain);
        return {
            content,
            conversation: conversationId,
            from: this.apiClient.context.userId,
            id: messageId,
            messageTimer: 0,
            source: conversation_2.PayloadBundleSource.LOCAL,
            state: conversation_2.PayloadBundleState.OUTGOING_SENT,
            timestamp: Date.now(),
            type: conversation_2.PayloadBundleType.CONVERSATION_CLEAR,
        };
    }
    async deleteMessageLocal(conversationId, messageIdToHide, sendAsProtobuf, conversationDomain) {
        const messageId = MessageBuilder_1.MessageBuilder.createId();
        const content = protocol_messaging_1.MessageHide.create({
            conversationId,
            messageId: messageIdToHide,
        });
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.HIDDEN]: content,
            messageId,
        });
        const { id: selfConversationId } = await this.getSelfConversation();
        await this.sendGenericMessage(this.apiClient.validatedClientId, selfConversationId, genericMessage, undefined, sendAsProtobuf, conversationDomain);
        return {
            content,
            conversation: conversationId,
            from: this.apiClient.context.userId,
            id: messageId,
            messageTimer: this.messageTimer.getMessageTimer(conversationId),
            source: conversation_2.PayloadBundleSource.LOCAL,
            state: conversation_2.PayloadBundleState.OUTGOING_SENT,
            timestamp: Date.now(),
            type: conversation_2.PayloadBundleType.MESSAGE_HIDE,
        };
    }
    async deleteMessageEveryone(conversationId, messageIdToDelete, userIds, sendAsProtobuf, conversationDomain) {
        const messageId = MessageBuilder_1.MessageBuilder.createId();
        const content = protocol_messaging_1.MessageDelete.create({
            messageId: messageIdToDelete,
        });
        const genericMessage = protocol_messaging_1.GenericMessage.create({
            [conversation_2.GenericMessageType.DELETED]: content,
            messageId,
        });
        await this.sendGenericMessage(this.apiClient.validatedClientId, conversationId, genericMessage, userIds, sendAsProtobuf, conversationDomain);
        return {
            content,
            conversation: conversationId,
            from: this.apiClient.context.userId,
            id: messageId,
            messageTimer: this.messageTimer.getMessageTimer(conversationId),
            source: conversation_2.PayloadBundleSource.LOCAL,
            state: conversation_2.PayloadBundleState.OUTGOING_SENT,
            timestamp: Date.now(),
            type: conversation_2.PayloadBundleType.MESSAGE_DELETE,
        };
    }
    shouldSendAsExternal(plainText, preKeyBundles) {
        const EXTERNAL_MESSAGE_THRESHOLD_BYTES = 200 * 1024;
        let clientCount = 0;
        for (const user in preKeyBundles) {
            clientCount += Object.keys(preKeyBundles[user]).length;
        }
        const messageInBytes = new Uint8Array(plainText).length;
        const estimatedPayloadInBytes = clientCount * messageInBytes;
        return estimatedPayloadInBytes > EXTERNAL_MESSAGE_THRESHOLD_BYTES;
    }
    leaveConversation(conversationId) {
        return this.apiClient.conversation.api.deleteMember(conversationId, this.apiClient.context.userId);
    }
    async leaveConversations(conversationIds) {
        if (!conversationIds) {
            const conversation = await this.getConversations();
            conversationIds = conversation
                .filter(conversation => conversation.type === conversation_1.CONVERSATION_TYPE.REGULAR)
                .map(conversation => conversation.id);
        }
        return Promise.all(conversationIds.map(conversationId => this.leaveConversation(conversationId)));
    }
    createConversation(name, otherUserIds = []) {
        const ids = typeof otherUserIds === 'string' ? [otherUserIds] : otherUserIds;
        const newConversation = {
            name,
            receipt_mode: null,
            users: ids,
        };
        return this.apiClient.conversation.api.postConversation(newConversation);
    }
    async getConversations(conversationIds) {
        if (!conversationIds || !conversationIds.length) {
            return this.apiClient.conversation.api.getAllConversations();
        }
        if (typeof conversationIds === 'string') {
            return this.apiClient.conversation.api.getConversation(conversationIds);
        }
        return this.apiClient.conversation.api.getConversationsByIds(conversationIds);
    }
    async getAsset({ assetId, assetToken, otrKey, sha256 }) {
        const request = await this.apiClient.asset.api.getAssetV3(assetId, assetToken);
        const encryptedBuffer = (await request.response).buffer;
        return AssetCryptography.decryptAsset({
            cipherText: Buffer.from(encryptedBuffer),
            keyBytes: Buffer.from(otrKey),
            sha256: Buffer.from(sha256),
        });
    }
    async getUnencryptedAsset(assetId, assetToken) {
        const request = await this.apiClient.asset.api.getAssetV3(assetId, assetToken);
        return (await request.response).buffer;
    }
    async addUser(conversationId, userIds) {
        const ids = Array.isArray(userIds) ? userIds : [userIds];
        if ((0, TypePredicateUtil_1.isStringArray)(ids)) {
            await this.apiClient.conversation.api.postMembers(conversationId, ids);
        }
        else if ((0, TypePredicateUtil_1.isQualifiedIdArray)(ids)) {
            await this.apiClient.conversation.api.postMembersV2(conversationId, ids);
        }
        return userIds;
    }
    async removeUser(conversationId, userId) {
        await this.apiClient.conversation.api.deleteMember(conversationId, userId);
        return userId;
    }
    /**
     * @param payloadBundle Outgoing message
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     * @param [callbacks] Optional callbacks that will be called when the message starts being sent and when it has been succesfully sent. Currently only used for `sendText`.
     * @returns Sent message
     */
    async send({ payloadBundle, userIds, sendAsProtobuf, conversationDomain, callbacks, }) {
        switch (payloadBundle.type) {
            case conversation_2.PayloadBundleType.ASSET:
                return this.sendFileData(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.ASSET_ABORT:
                return this.sendFileAbort(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.ASSET_META:
                return this.sendFileMetaData(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.ASSET_IMAGE:
                return this.sendImage(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.BUTTON_ACTION:
                return this.sendButtonAction(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.BUTTON_ACTION_CONFIRMATION:
                return this.sendButtonActionConfirmation(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.CALL:
                return this.sendCall(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.CLIENT_ACTION: {
                if (payloadBundle.content.clientAction === protocol_messaging_1.ClientAction.RESET_SESSION) {
                    return this.sendSessionReset(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
                }
                throw new Error(`No send method implemented for "${payloadBundle.type}" and ClientAction "${payloadBundle.content}".`);
            }
            case conversation_2.PayloadBundleType.COMPOSITE:
                return this.sendComposite(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.CONFIRMATION:
                return this.sendConfirmation(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.LOCATION:
                return this.sendLocation(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.MESSAGE_EDIT:
                return this.sendEditedText(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.PING:
                return this.sendKnock(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.REACTION:
                return this.sendReaction(payloadBundle, userIds, sendAsProtobuf, conversationDomain);
            case conversation_2.PayloadBundleType.TEXT:
                return this.sendText(payloadBundle, userIds, sendAsProtobuf, conversationDomain, callbacks);
            default:
                throw new Error(`No send method implemented for "${payloadBundle['type']}".`);
        }
    }
    sendTypingStart(conversationId) {
        return this.apiClient.conversation.api.postTyping(conversationId, { status: data_1.CONVERSATION_TYPING.STARTED });
    }
    sendTypingStop(conversationId) {
        return this.apiClient.conversation.api.postTyping(conversationId, { status: data_1.CONVERSATION_TYPING.STOPPED });
    }
    setConversationMutedStatus(conversationId, status, muteTimestamp) {
        if (typeof muteTimestamp === 'number') {
            muteTimestamp = new Date(muteTimestamp);
        }
        const payload = {
            otr_muted_ref: muteTimestamp.toISOString(),
            otr_muted_status: status,
        };
        return this.apiClient.conversation.api.putMembershipProperties(conversationId, payload);
    }
    toggleArchiveConversation(conversationId, archived, archiveTimestamp = new Date()) {
        if (typeof archiveTimestamp === 'number') {
            archiveTimestamp = new Date(archiveTimestamp);
        }
        const payload = {
            otr_archived: archived,
            otr_archived_ref: archiveTimestamp.toISOString(),
        };
        return this.apiClient.conversation.api.putMembershipProperties(conversationId, payload);
    }
    setMemberConversationRole(conversationId, userId, conversationRole) {
        return this.apiClient.conversation.api.putOtherMember(userId, conversationId, {
            conversation_role: conversationRole,
        });
    }
}
exports.ConversationService = ConversationService;
//# sourceMappingURL=ConversationService.js.map