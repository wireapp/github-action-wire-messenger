/// <reference types="node" />
import type { APIClient } from '@wireapp/api-client';
import { Conversation, DefaultConversationRoleName, MutedStatus, QualifiedUserClients, UserClients } from '@wireapp/api-client/src/conversation/';
import type { ConversationMemberLeaveEvent } from '@wireapp/api-client/src/event/';
import type { QualifiedId, UserPreKeyBundleMap } from '@wireapp/api-client/src/user/';
import { GenericMessage } from '@wireapp/protocol-messaging';
import { AssetService, MessageTimer } from '../conversation/';
import type { RemoteData } from '../conversation/content/';
import type { CryptographyService } from '../cryptography/';
import { MessageBuilder } from './message/MessageBuilder';
import type { ButtonActionConfirmationMessage, ButtonActionMessage, CallMessage, ClearConversationMessage, CompositeMessage, ConfirmationMessage, DeleteMessage, EditedTextMessage, FileAssetAbortMessage, FileAssetMessage, FileAssetMetaDataMessage, HideMessage, ImageAssetMessage, LocationMessage, OtrMessage, PingMessage, ReactionMessage, ResetSessionMessage, TextMessage } from './message/OtrMessage';
export interface MessageSendingCallbacks {
    onStart?: (message: GenericMessage) => void;
    onSuccess?: (message: GenericMessage, sentTime?: string) => void;
}
export declare class ConversationService {
    private readonly apiClient;
    private readonly cryptographyService;
    private readonly assetService;
    readonly messageTimer: MessageTimer;
    readonly messageBuilder: MessageBuilder;
    private readonly messageService;
    constructor(apiClient: APIClient, cryptographyService: CryptographyService, assetService: AssetService);
    private createEphemeral;
    private getQualifiedPreKeyBundle;
    getPreKeyBundleMap(conversationId: string, userIds?: string[] | UserClients): Promise<UserPreKeyBundleMap>;
    private getSelfConversation;
    private sendExternalGenericMessage;
    private sendFederatedGenericMessage;
    private sendGenericMessage;
    private sendButtonAction;
    private sendButtonActionConfirmation;
    private sendComposite;
    private sendConfirmation;
    private sendEditedText;
    private sendFileData;
    private sendFileMetaData;
    private sendFileAbort;
    private sendImage;
    private sendLocation;
    private sendKnock;
    private sendReaction;
    private sendSessionReset;
    private sendCall;
    private sendText;
    clearConversation(conversationId: string, timestamp?: number | Date, messageId?: string, sendAsProtobuf?: boolean, conversationDomain?: string): Promise<ClearConversationMessage>;
    deleteMessageLocal(conversationId: string, messageIdToHide: string, sendAsProtobuf?: boolean, conversationDomain?: string): Promise<HideMessage>;
    deleteMessageEveryone(conversationId: string, messageIdToDelete: string, userIds?: string[] | QualifiedId[] | UserClients | QualifiedUserClients, sendAsProtobuf?: boolean, conversationDomain?: string): Promise<DeleteMessage>;
    private shouldSendAsExternal;
    leaveConversation(conversationId: string): Promise<ConversationMemberLeaveEvent>;
    leaveConversations(conversationIds?: string[]): Promise<ConversationMemberLeaveEvent[]>;
    createConversation(name: string, otherUserIds?: string | string[]): Promise<Conversation>;
    getConversations(conversationId: string): Promise<Conversation>;
    getConversations(conversationIds?: string[]): Promise<Conversation[]>;
    getAsset({ assetId, assetToken, otrKey, sha256 }: RemoteData): Promise<Buffer>;
    getUnencryptedAsset(assetId: string, assetToken?: string): Promise<ArrayBuffer>;
    addUser<T extends string | string[] | QualifiedId | QualifiedId[]>(conversationId: string, userIds: T): Promise<T>;
    removeUser(conversationId: string, userId: string): Promise<string>;
    /**
     * @param payloadBundle Outgoing message
     * @param userIds Only send message to specified user IDs or to certain clients of specified user IDs
     * @param [callbacks] Optional callbacks that will be called when the message starts being sent and when it has been succesfully sent. Currently only used for `sendText`.
     * @returns Sent message
     */
    send({ payloadBundle, userIds, sendAsProtobuf, conversationDomain, callbacks, }: {
        payloadBundle: OtrMessage;
        userIds?: string[] | QualifiedId[] | UserClients | QualifiedUserClients;
        sendAsProtobuf?: boolean;
        conversationDomain?: string;
        callbacks?: MessageSendingCallbacks;
    }): Promise<ButtonActionMessage | ButtonActionConfirmationMessage | CallMessage | CompositeMessage | ConfirmationMessage | EditedTextMessage | FileAssetAbortMessage | FileAssetMessage | FileAssetMetaDataMessage | ImageAssetMessage | LocationMessage | PingMessage | ReactionMessage | ResetSessionMessage | TextMessage>;
    sendTypingStart(conversationId: string): Promise<void>;
    sendTypingStop(conversationId: string): Promise<void>;
    setConversationMutedStatus(conversationId: string, status: MutedStatus, muteTimestamp: number | Date): Promise<void>;
    toggleArchiveConversation(conversationId: string, archived: boolean, archiveTimestamp?: number | Date): Promise<void>;
    setMemberConversationRole(conversationId: string, userId: string, conversationRole: DefaultConversationRoleName | string): Promise<void>;
}
