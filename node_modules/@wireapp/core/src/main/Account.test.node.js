"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_status_codes_1 = require("http-status-codes");
const api_client_1 = require("@wireapp/api-client");
const auth_1 = require("@wireapp/api-client/src/auth");
const client_1 = require("@wireapp/api-client/src/client");
const self_1 = require("@wireapp/api-client/src/self");
const conversation_1 = require("@wireapp/api-client/src/conversation");
const http_1 = require("@wireapp/api-client/src/http");
const notification_1 = require("@wireapp/api-client/src/notification");
const commons_1 = require("@wireapp/commons");
const protocol_messaging_1 = require("@wireapp/protocol-messaging");
const Proteus = __importStar(require("@wireapp/proteus"));
const store_engine_1 = require("@wireapp/store-engine");
const nock = require("nock");
const Account_1 = require("./Account");
const conversation_2 = require("./conversation");
const BASE_URL = 'mock-backend.wire.com';
const MOCK_BACKEND = {
    name: 'mock',
    rest: `https://${BASE_URL}`,
    ws: `wss://${BASE_URL}`,
};
async function createAccount(storageName = `test-${Date.now()}`) {
    const apiClient = new api_client_1.APIClient({ urls: MOCK_BACKEND });
    const account = new Account_1.Account(apiClient);
    await account.initServices(new store_engine_1.MemoryEngine());
    return account;
}
describe('Account', () => {
    const CLIENT_ID = '4e37b32f57f6da55';
    const accessTokenData = {
        access_token: 'iJCRCjc8oROO-dkrkqCXOade997oa8Jhbz6awMUQPBQo80VenWqp_oNvfY6AnU5BxEsdDPOBfBP-uz_b0gAKBQ==.v=1.k=1.d=1498600993.t=a.l=.u=aaf9a833-ef30-4c22-86a0-9adc8a15b3b4.c=15037015562284012115',
        expires_in: 900,
        token_type: 'Bearer',
        user: 'aaf9a833-ef30-4c22-86a0-9adc8a15b3b4',
    };
    beforeAll(async () => {
        await Proteus.init();
    });
    beforeEach(() => {
        nock(MOCK_BACKEND.rest)
            .post(auth_1.AuthAPI.URL.LOGIN, body => body.email && body.password)
            .query(() => true)
            .reply((uri, body) => {
            if (body.password === 'wrong') {
                return [
                    http_status_codes_1.StatusCodes.FORBIDDEN,
                    JSON.stringify({
                        code: http_status_codes_1.StatusCodes.FORBIDDEN,
                        label: 'invalid-credentials',
                        message: 'Authentication failed.',
                    }),
                ];
            }
            return [http_status_codes_1.StatusCodes.OK, JSON.stringify(accessTokenData)];
        });
        nock(MOCK_BACKEND.rest).post(`${auth_1.AuthAPI.URL.ACCESS}/${auth_1.AuthAPI.URL.LOGOUT}`).reply(http_status_codes_1.StatusCodes.OK, undefined);
        nock(MOCK_BACKEND.rest).post(auth_1.AuthAPI.URL.ACCESS).reply(http_status_codes_1.StatusCodes.OK, accessTokenData);
        nock(MOCK_BACKEND.rest).post(client_1.ClientAPI.URL.CLIENTS).reply(http_status_codes_1.StatusCodes.OK, { id: CLIENT_ID });
        nock(MOCK_BACKEND.rest)
            .post(new RegExp(`${conversation_1.ConversationAPI.URL.CONVERSATIONS}/.*/${conversation_1.ConversationAPI.URL.OTR}/${conversation_1.ConversationAPI.URL.MESSAGES}`))
            .query({ ignore_missing: false })
            .reply(http_status_codes_1.StatusCodes.OK)
            .persist();
        nock(MOCK_BACKEND.rest)
            .get(`${notification_1.NotificationAPI.URL.NOTIFICATION}/${notification_1.NotificationAPI.URL.LAST}`)
            .query({ client: CLIENT_ID })
            .reply(http_status_codes_1.StatusCodes.OK, {});
        nock(MOCK_BACKEND.rest)
            .get(notification_1.NotificationAPI.URL.NOTIFICATION)
            .query({ client: CLIENT_ID, size: 10000 })
            .reply(http_status_codes_1.StatusCodes.OK, { has_more: false, notifications: [] })
            .persist();
        nock(MOCK_BACKEND.rest)
            .get(client_1.ClientAPI.URL.CLIENTS)
            .reply(http_status_codes_1.StatusCodes.OK, [{ id: CLIENT_ID }]);
        nock(MOCK_BACKEND.rest)
            .get(self_1.SelfAPI.URL.SELF)
            .reply(http_status_codes_1.StatusCodes.OK, {
            email: 'email@example.com',
            handle: 'exampleuser',
            locale: 'en',
            qualified_id: {
                domain: 'example.com',
                id: '024174ec-c098-4104-9424-3849804acb78',
            },
            accent_id: commons_1.AccentColor.AccentColorID.BRIGHT_ORANGE,
            picture: [],
            name: 'Example User',
            id: '024174ec-c098-4104-9424-3849804acb78',
            assets: [],
        });
    });
    describe('"createText"', () => {
        it('creates a text payload', async () => {
            const account = await createAccount();
            await account.login({
                clientType: client_1.ClientType.TEMPORARY,
                email: 'hello@example.com',
                password: 'my-secret',
            });
            expect(account['apiClient'].context.userId).toBeDefined();
            const text = 'FIFA World Cup';
            const payload = account.service.conversation.messageBuilder.createText({ conversationId: '', text }).build();
            expect(payload.timestamp).toBeGreaterThan(0);
        });
    });
    describe('"init"', () => {
        it('initializes the Protocol buffers', async () => {
            const account = new Account_1.Account();
            await account.initServices(new store_engine_1.MemoryEngine());
            expect(account.service.conversation).toBeDefined();
            expect(account.service.cryptography).toBeDefined();
            const message = protocol_messaging_1.GenericMessage.create({
                messageId: '2d7cb6d8-118f-11e8-b642-0ed5f89f718b',
                text: protocol_messaging_1.Text.create({ content: 'Hello, World!' }),
            });
            expect(message.content).toBe('text');
        });
    });
    describe('"login"', () => {
        it('logs in with correct credentials', async () => {
            const apiClient = new api_client_1.APIClient({ urls: MOCK_BACKEND });
            const account = new Account_1.Account(apiClient);
            await account.initServices(new store_engine_1.MemoryEngine());
            const { clientId, clientType, userId } = await account.login({
                clientType: client_1.ClientType.TEMPORARY,
                email: 'hello@example.com',
                password: 'my-secret',
            });
            expect(clientId).toBe(CLIENT_ID);
            expect(commons_1.ValidationUtil.isUUIDv4(userId)).toBe(true);
            expect(clientType).toBe(client_1.ClientType.TEMPORARY);
        });
        it('does not log in with incorrect credentials', async () => {
            const apiClient = new api_client_1.APIClient({ urls: MOCK_BACKEND });
            const account = new Account_1.Account(apiClient);
            await account.initServices(new store_engine_1.MemoryEngine());
            try {
                await account.login({
                    clientType: client_1.ClientType.TEMPORARY,
                    email: 'hello@example.com',
                    password: 'wrong',
                });
                fail('Should not be logged in');
            }
            catch (error) {
                const backendError = error;
                expect(backendError.code).toBe(http_status_codes_1.StatusCodes.FORBIDDEN);
                expect(backendError.label).toBe(http_1.BackendErrorLabel.INVALID_CREDENTIALS);
            }
        });
    });
    it('emits text messages', async (done) => {
        const account = await createAccount();
        await account.login({
            clientType: client_1.ClientType.TEMPORARY,
            email: 'hello@example.com',
            password: 'my-secret',
        });
        await account.listen();
        spyOn(account.service.notification, 'handleEvent').and.returnValue({ type: conversation_2.PayloadBundleType.TEXT });
        account.service.notification.on(conversation_2.PayloadBundleType.TEXT, message => {
            expect(message.type).toBe(conversation_2.PayloadBundleType.TEXT);
        });
        account.on(conversation_2.PayloadBundleType.TEXT, message => {
            expect(message.type).toBe(conversation_2.PayloadBundleType.TEXT);
            done();
        });
        await account.service.notification.handleNotification({
            payload: [{}],
            transient: true,
        }, conversation_2.PayloadBundleSource.WEBSOCKET);
    });
});
//# sourceMappingURL=Account.test.node.js.map