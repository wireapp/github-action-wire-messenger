"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptographyService = void 0;
const cryptobox_1 = require("@wireapp/cryptobox");
const proteus_1 = require("@wireapp/proteus");
const protocol_messaging_1 = require("@wireapp/protocol-messaging");
const bazinga64_1 = require("bazinga64");
const logdown_1 = __importDefault(require("logdown"));
const conversation_1 = require("../conversation");
const CryptographyDatabaseRepository_1 = require("./CryptographyDatabaseRepository");
const GenericMessageMapper_1 = require("./GenericMessageMapper");
class CryptographyService {
    constructor(apiClient, storeEngine) {
        this.apiClient = apiClient;
        this.storeEngine = storeEngine;
        this.cryptobox = new cryptobox_1.Cryptobox(this.storeEngine);
        this.database = new CryptographyDatabaseRepository_1.CryptographyDatabaseRepository(this.storeEngine);
        this.logger = (0, logdown_1.default)('@wireapp/core/cryptography/CryptographyService', {
            logger: console,
            markdown: false,
        });
    }
    static constructSessionId(userId, clientId) {
        return `${userId}@${clientId}`;
    }
    static convertArrayRecipientsToBase64(recipients) {
        return Object.fromEntries(Object.entries(recipients).map(([userId, otrClientMap]) => {
            const otrClientMapWithBase64 = Object.fromEntries(Object.entries(otrClientMap).map(([clientId, payload]) => {
                return [clientId, bazinga64_1.Encoder.toBase64(payload).asString];
            }));
            return [userId, otrClientMapWithBase64];
        }));
    }
    static convertBase64RecipientsToArray(recipients) {
        return Object.fromEntries(Object.entries(recipients).map(([userId, otrClientMap]) => {
            const otrClientMapWithUint8Array = Object.fromEntries(Object.entries(otrClientMap).map(([clientId, payload]) => {
                return [clientId, bazinga64_1.Decoder.fromBase64(payload).asBytes];
            }));
            return [userId, otrClientMapWithUint8Array];
        }));
    }
    async createCryptobox() {
        const initialPreKeys = await this.cryptobox.create();
        return initialPreKeys
            .map(preKey => {
            const preKeyJson = this.cryptobox.serialize_prekey(preKey);
            if (preKeyJson.id !== proteus_1.keys.PreKey.MAX_PREKEY_ID) {
                return preKeyJson;
            }
            return { id: -1, key: '' };
        })
            .filter(serializedPreKey => serializedPreKey.key);
    }
    decrypt(sessionId, encodedCiphertext) {
        this.logger.log(`Decrypting message for session ID "${sessionId}"`);
        const messageBytes = bazinga64_1.Decoder.fromBase64(encodedCiphertext).asBytes;
        return this.cryptobox.decrypt(sessionId, messageBytes.buffer);
    }
    static dismantleSessionId(sessionId) {
        return sessionId.split('@');
    }
    async encryptQualified(plainText, preKeyBundles) {
        const qualifiedOTRRecipients = {};
        for (const [domain, preKeyBundleMap] of Object.entries(preKeyBundles)) {
            qualifiedOTRRecipients[domain] = await this.encrypt(plainText, preKeyBundleMap);
        }
        return qualifiedOTRRecipients;
    }
    async encrypt(plainText, preKeyBundles) {
        const recipients = {};
        const bundles = [];
        for (const userId in preKeyBundles) {
            recipients[userId] = {};
            for (const clientId in preKeyBundles[userId]) {
                const { key: base64PreKey } = preKeyBundles[userId][clientId];
                const sessionId = CryptographyService.constructSessionId(userId, clientId);
                bundles.push(this.encryptPayloadForSession(sessionId, plainText, base64PreKey));
            }
        }
        const payloads = await Promise.all(bundles);
        payloads.forEach(payload => {
            const { encryptedPayload, sessionId } = payload;
            const [userId, clientId] = CryptographyService.dismantleSessionId(sessionId);
            recipients[userId][clientId] = encryptedPayload;
        });
        return recipients;
    }
    async encryptPayloadForSession(sessionId, plainText, base64EncodedPreKey) {
        this.logger.log(`Encrypting payload for session ID "${sessionId}"`);
        let encryptedPayload;
        try {
            const decodedPreKeyBundle = bazinga64_1.Decoder.fromBase64(base64EncodedPreKey).asBytes;
            const payloadAsArrayBuffer = await this.cryptobox.encrypt(sessionId, plainText, decodedPreKeyBundle.buffer);
            encryptedPayload = new Uint8Array(payloadAsArrayBuffer);
        }
        catch (error) {
            this.logger.error(`Could not encrypt payload: ${error.message}`);
            encryptedPayload = new Uint8Array(Buffer.from('ðŸ’£', 'utf-8'));
        }
        return { encryptedPayload, sessionId };
    }
    async initCryptobox() {
        await this.cryptobox.load();
    }
    deleteCryptographyStores() {
        return this.database.deleteStores();
    }
    async resetSession(sessionId) {
        await this.cryptobox.session_delete(sessionId);
        this.logger.log(`Deleted session ID "${sessionId}".`);
    }
    async decodeGenericMessage(otrMessage, source) {
        const { from, data: { sender, text: cipherText }, } = otrMessage;
        const sessionId = CryptographyService.constructSessionId(from, sender);
        const decryptedMessage = await this.decrypt(sessionId, cipherText);
        const genericMessage = protocol_messaging_1.GenericMessage.decode(decryptedMessage);
        if (genericMessage.content === conversation_1.GenericMessageType.EPHEMERAL) {
            const unwrappedMessage = GenericMessageMapper_1.GenericMessageMapper.mapGenericMessage(genericMessage.ephemeral, otrMessage, source);
            unwrappedMessage.id = genericMessage.messageId;
            if (genericMessage.ephemeral) {
                const expireAfterMillis = genericMessage.ephemeral.expireAfterMillis;
                unwrappedMessage.messageTimer =
                    typeof expireAfterMillis === 'number' ? expireAfterMillis : expireAfterMillis.toNumber();
            }
            return unwrappedMessage;
        }
        return GenericMessageMapper_1.GenericMessageMapper.mapGenericMessage(genericMessage, otrMessage, source);
    }
}
exports.CryptographyService = CryptographyService;
//# sourceMappingURL=CryptographyService.js.map