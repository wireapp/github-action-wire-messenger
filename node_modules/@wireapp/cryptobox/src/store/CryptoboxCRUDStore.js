"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoboxCRUDStore = exports.CRUDStoreStores = exports.CRUDStoreKeys = void 0;
const proteus_1 = require("@wireapp/proteus");
const store_engine_1 = require("@wireapp/store-engine");
const bazinga64_1 = require("bazinga64");
const SerialisedRecord_1 = require("./SerialisedRecord");
var CRUDStoreKeys;
(function (CRUDStoreKeys) {
    CRUDStoreKeys["LOCAL_IDENTITY"] = "local_identity";
})(CRUDStoreKeys = exports.CRUDStoreKeys || (exports.CRUDStoreKeys = {}));
var CRUDStoreStores;
(function (CRUDStoreStores) {
    CRUDStoreStores["LOCAL_IDENTITY"] = "keys";
    CRUDStoreStores["PRE_KEYS"] = "prekeys";
    CRUDStoreStores["SESSIONS"] = "sessions";
})(CRUDStoreStores = exports.CRUDStoreStores || (exports.CRUDStoreStores = {}));
class CryptoboxCRUDStore {
    constructor(engine) {
        this.engine = engine;
    }
    from_store(record) {
        return typeof record.serialised === 'string'
            ? bazinga64_1.Decoder.fromBase64(record.serialised).asBytes.buffer
            : record.serialised;
    }
    to_store(serialised) {
        return bazinga64_1.Encoder.toBase64(serialised).asString;
    }
    async delete_all() {
        await this.engine.deleteAll(CryptoboxCRUDStore.STORES.LOCAL_IDENTITY);
        await this.engine.deleteAll(CryptoboxCRUDStore.STORES.PRE_KEYS);
        await this.engine.deleteAll(CryptoboxCRUDStore.STORES.SESSIONS);
        return true;
    }
    async delete_prekey(prekeyId) {
        await this.engine.delete(CryptoboxCRUDStore.STORES.PRE_KEYS, prekeyId.toString());
        return prekeyId;
    }
    async load_identity() {
        try {
            const record = await this.engine.read(CryptoboxCRUDStore.STORES.LOCAL_IDENTITY, CryptoboxCRUDStore.KEYS.LOCAL_IDENTITY);
            const payload = this.from_store(record);
            await proteus_1.init();
            return proteus_1.keys.IdentityKeyPair.deserialise(payload);
        }
        catch (error) {
            if (error instanceof store_engine_1.error.RecordNotFoundError ||
                error.constructor.name === store_engine_1.error.RecordNotFoundError.name) {
                return undefined;
            }
            throw error;
        }
    }
    async load_prekey(prekeyId) {
        try {
            const record = await this.engine.read(CryptoboxCRUDStore.STORES.PRE_KEYS, prekeyId.toString());
            const payload = this.from_store(record);
            await proteus_1.init();
            return proteus_1.keys.PreKey.deserialise(payload);
        }
        catch (error) {
            if (error instanceof store_engine_1.error.RecordNotFoundError ||
                error.constructor.name === store_engine_1.error.RecordNotFoundError.name) {
                return undefined;
            }
            throw error;
        }
    }
    async load_prekeys() {
        await proteus_1.init();
        const records = await this.engine.readAll(CryptoboxCRUDStore.STORES.PRE_KEYS);
        return records.map(record => {
            const payload = this.from_store(record);
            return proteus_1.keys.PreKey.deserialise(payload);
        });
    }
    async save_identity(identity) {
        const serialised = this.to_store(identity.serialise());
        const payload = new SerialisedRecord_1.SerialisedRecord(serialised, CryptoboxCRUDStore.KEYS.LOCAL_IDENTITY);
        await this.engine.create(CryptoboxCRUDStore.STORES.LOCAL_IDENTITY, payload.id, payload);
        return identity;
    }
    async save_prekey(preKey) {
        const serialised = this.to_store(preKey.serialise());
        const payload = new SerialisedRecord_1.SerialisedRecord(serialised, preKey.key_id.toString());
        await this.engine.create(CryptoboxCRUDStore.STORES.PRE_KEYS, payload.id, payload);
        return preKey;
    }
    async save_prekeys(preKeys) {
        await Promise.all(preKeys.map(pre_key => this.save_prekey(pre_key)));
        return preKeys;
    }
    async create_session(sessionId, session) {
        const serialised = this.to_store(session.serialise());
        const payload = new SerialisedRecord_1.SerialisedRecord(serialised, sessionId);
        await this.engine.create(CryptoboxCRUDStore.STORES.SESSIONS, payload.id, payload);
        return session;
    }
    async read_session(identity, sessionId) {
        const record = await this.engine.read(CryptoboxCRUDStore.STORES.SESSIONS, sessionId);
        const payload = this.from_store(record);
        return proteus_1.session.Session.deserialise(identity, payload);
    }
    async read_sessions(identity) {
        const sessionIds = await this.engine.readAllPrimaryKeys(CryptoboxCRUDStore.STORES.SESSIONS);
        const sessions = {};
        await Promise.all(sessionIds.map(async (sessionId) => {
            sessions[sessionId] = await this.read_session(identity, sessionId);
        }));
        return sessions;
    }
    async update_session(sessionId, session) {
        const serialised = this.to_store(session.serialise());
        const payload = new SerialisedRecord_1.SerialisedRecord(serialised, sessionId);
        await this.engine.update(CryptoboxCRUDStore.STORES.SESSIONS, payload.id, { serialised: payload.serialised });
        return session;
    }
    async delete_session(sessionId) {
        const primary_key = await this.engine.delete(CryptoboxCRUDStore.STORES.SESSIONS, sessionId);
        return primary_key;
    }
}
exports.CryptoboxCRUDStore = CryptoboxCRUDStore;
CryptoboxCRUDStore.KEYS = CRUDStoreKeys;
CryptoboxCRUDStore.STORES = CRUDStoreStores;
//# sourceMappingURL=CryptoboxCRUDStore.js.map