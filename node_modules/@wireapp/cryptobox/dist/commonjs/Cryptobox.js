"use strict";
/*
 * Wire
 * Copyright (C) 2018 Wire Swiss GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see http://www.gnu.org/licenses/.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cryptobox = void 0;
const lru_cache_1 = require("@wireapp/lru-cache");
const priority_queue_1 = require("@wireapp/priority-queue");
const proteus_1 = require("@wireapp/proteus");
const bazinga64_1 = require("bazinga64");
const events_1 = require("events");
const logdown_1 = __importDefault(require("logdown"));
const CryptoboxSession_1 = require("./CryptoboxSession");
const DecryptionError_1 = require("./DecryptionError");
const error_1 = require("./error/");
const InvalidPreKeyFormatError_1 = require("./InvalidPreKeyFormatError");
const store_1 = require("./store/");
const DEFAULT_CAPACITY = 1000;
const { version } = require('../../package.json');
var TOPIC;
(function (TOPIC) {
    TOPIC["NEW_PREKEYS"] = "new-prekeys";
    TOPIC["NEW_SESSION"] = "new-session";
})(TOPIC || (TOPIC = {}));
let Cryptobox = /** @class */ (() => {
    class Cryptobox extends events_1.EventEmitter {
        constructor(engine, minimumAmountOfPreKeys = 1) {
            super();
            this.queues = new lru_cache_1.LRUCache(DEFAULT_CAPACITY);
            if (!engine) {
                throw new Error('You cannot initialize Cryptobox without a storage component.');
            }
            if (minimumAmountOfPreKeys > proteus_1.keys.PreKey.MAX_PREKEY_ID) {
                minimumAmountOfPreKeys = proteus_1.keys.PreKey.MAX_PREKEY_ID;
            }
            this.logger = logdown_1.default('@wireapp/cryptobox/Cryptobox', {
                logger: console,
                markdown: false,
            });
            this.cachedSessions = new lru_cache_1.LRUCache(DEFAULT_CAPACITY);
            this.minimumAmountOfPreKeys = minimumAmountOfPreKeys;
            this.store = new store_1.CryptoboxCRUDStore(engine);
            const storageEngineName = engine.constructor.name;
            this.logger.log(`Constructed Cryptobox. Minimum amount of PreKeys is "${minimumAmountOfPreKeys}". Storage engine is "${storageEngineName}".`);
        }
        get_session_queue(sessionId) {
            let queue = this.queues.get(sessionId);
            if (!queue) {
                queue = new priority_queue_1.PriorityQueue({ maxRetries: 0 });
                this.queues.set(sessionId, queue);
            }
            return queue;
        }
        save_session_in_cache(session) {
            this.logger.log(`Saving Session with ID "${session.id}" in cache...`);
            this.cachedSessions.set(session.id, session);
            return session;
        }
        load_session_from_cache(sessionId) {
            this.logger.log(`Trying to load Session with ID "${sessionId}" from cache...`);
            return this.cachedSessions.get(sessionId);
        }
        remove_session_from_cache(sessionId) {
            this.logger.log(`Removing Session with ID "${sessionId}" from cache...`);
            this.cachedSessions.delete(sessionId);
        }
        create() {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.log('Initializing Cryptobox. Creating local identity...');
                yield this.create_new_identity();
                const lastResortPreKey = yield this.create_last_resort_prekey();
                this.logger.log(`Created Last Resort PreKey with ID "${lastResortPreKey.key_id}".`);
                return this.init(false);
            });
        }
        load() {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.log('Initializing Cryptobox. Loading local identity...');
                const identity = yield this.store.load_identity();
                if (!identity) {
                    throw new error_1.CryptoboxError('Failed to load local identity');
                }
                this.identity = identity;
                this.logger.log('Initialized Cryptobox with existing local identity.');
                this.logger.log(`Identity fingerprint is "${identity.public_key.fingerprint()}".`);
                this.logger.log('Loading PreKeys...');
                const preKeysFromStorage = yield this.store.load_prekeys();
                const lastResortPreKey = preKeysFromStorage.find(preKey => preKey.key_id === proteus_1.keys.PreKey.MAX_PREKEY_ID);
                if (!lastResortPreKey) {
                    throw new error_1.CryptoboxError('Failed to load last resort PreKey');
                }
                this.logger.log(`Loaded Last Resort PreKey with ID "${lastResortPreKey.key_id}".`);
                this.lastResortPreKey = lastResortPreKey;
                this.logger.log(`Loaded "${this.minimumAmountOfPreKeys - 1}" standard PreKeys...`);
                return this.init(true);
            });
        }
        init(publishPrekeys) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.refill_prekeys(publishPrekeys);
                const prekeys = yield this.store.load_prekeys();
                return prekeys.sort((a, b) => a.key_id - b.key_id);
            });
        }
        get_serialized_last_resort_prekey() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.lastResortPreKey) {
                    return this.serialize_prekey(this.lastResortPreKey);
                }
                throw new error_1.CryptoboxError('No last resort PreKey available.');
            });
        }
        get_prekey(prekey_id = proteus_1.keys.PreKey.MAX_PREKEY_ID) {
            return this.store.load_prekey(prekey_id);
        }
        get_prekey_bundle(preKeyId = proteus_1.keys.PreKey.MAX_PREKEY_ID) {
            return __awaiter(this, void 0, void 0, function* () {
                const preKey = yield this.get_prekey(preKeyId);
                if (!this.identity) {
                    throw new error_1.CryptoboxError('No local identity available.');
                }
                if (!preKey) {
                    throw new error_1.CryptoboxError(`PreKey with ID "${preKeyId}" cannot be found.`);
                }
                return new proteus_1.keys.PreKeyBundle(this.identity.public_key, preKey);
            });
        }
        get_serialized_standard_prekeys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prekeys = yield this.store.load_prekeys();
                return prekeys
                    .filter((preKey) => {
                    const isLastResortPreKey = preKey.key_id === proteus_1.keys.PreKey.MAX_PREKEY_ID;
                    return !isLastResortPreKey;
                })
                    .map((preKey) => this.serialize_prekey(preKey));
            });
        }
        publish_event(topic, event) {
            this.emit(topic, event);
            this.logger.log(`Published event "${topic}".`, event);
        }
        publish_prekeys(newPreKeys) {
            if (newPreKeys.length > 0) {
                this.publish_event(Cryptobox.TOPIC.NEW_PREKEYS, newPreKeys);
            }
        }
        publish_session_id(session) {
            this.publish_event(Cryptobox.TOPIC.NEW_SESSION, session.id);
        }
        /**
         * This method returns all PreKeys available, respecting the minimum required amount of PreKeys.
         * If all available PreKeys don't meet the minimum PreKey amount, new PreKeys will be created.
         */
        refill_prekeys(publishPrekeys = true) {
            return __awaiter(this, void 0, void 0, function* () {
                const prekeys = yield this.store.load_prekeys();
                const missingAmount = Math.max(0, this.minimumAmountOfPreKeys - prekeys.length);
                if (missingAmount > 0) {
                    const startId = prekeys.reduce((currentHighestValue, currentPreKey) => {
                        const isLastResortPreKey = currentPreKey.key_id === proteus_1.keys.PreKey.MAX_PREKEY_ID;
                        return isLastResortPreKey ? currentHighestValue : Math.max(currentPreKey.key_id + 1, currentHighestValue);
                    }, 0);
                    this.logger.warn(`There are not enough PreKeys in the storage. Generating "${missingAmount}" new PreKey(s), starting from ID "${startId}"...`);
                    const newPreKeys = yield this.new_prekeys(startId, missingAmount);
                    this.logger.log(`Generated PreKeys from ID "${newPreKeys[0].key_id}" to ID "${newPreKeys[newPreKeys.length - 1].key_id}".`);
                    if (publishPrekeys) {
                        this.publish_prekeys(newPreKeys);
                    }
                    prekeys.push(...newPreKeys);
                }
                return prekeys;
            });
        }
        create_new_identity() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.store.delete_all();
                const identity = yield proteus_1.keys.IdentityKeyPair.new();
                this.logger.warn('Cleaned cryptographic items prior to saving a new local identity.');
                this.logger.log(`Created new local identity. Fingerprint is "${identity.public_key.fingerprint()}".`);
                return this.save_identity(identity);
            });
        }
        save_identity(identity) {
            this.identity = identity;
            return this.store.save_identity(identity);
        }
        /**
         * Creates (and persists) a new session which can be used for cryptographic operations (encryption & decryption) from
         * a remote PreKey bundle. This function is automatically called on every execution of "encrypt" and "decrypt" so you
         * might not need to call it yourself. However, it has been marked as "public" because there are some cases where you
         * just need the session without executing an encryption or decryption. This is the case when you for example just
         * want to show the fingerprint of the remote party.
         */
        session_from_prekey(sessionId, preKeyBundle) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.session_load(sessionId);
                }
                catch (sessionLoadError) {
                    this.logger.warn(`Creating new session because session with ID "${sessionId}" could not be loaded: ${sessionLoadError.message}`);
                    let bundle;
                    try {
                        bundle = proteus_1.keys.PreKeyBundle.deserialise(preKeyBundle);
                    }
                    catch (error) {
                        const message = `PreKey bundle for session "${sessionId}" has an unsupported format: ${error.message}`;
                        throw new InvalidPreKeyFormatError_1.InvalidPreKeyFormatError(message);
                    }
                    if (this.identity) {
                        const session = yield proteus_1.session.Session.init_from_prekey(this.identity, bundle);
                        const cryptobox_session = new CryptoboxSession_1.CryptoboxSession(sessionId, session);
                        return this.session_save(cryptobox_session);
                    }
                    throw new error_1.CryptoboxError('No local identity available.');
                }
            });
        }
        /**
         * Uses a cipher message to create a new session and to decrypt to message which the given cipher message contains.
         * Saving the newly created session is not needed as it's done during the inbuilt decryption phase.
         */
        session_from_message(sessionId, envelope) {
            return __awaiter(this, void 0, void 0, function* () {
                const env = proteus_1.message.Envelope.deserialise(envelope);
                if (this.identity) {
                    const [session, decrypted] = yield proteus_1.session.Session.init_from_message(this.identity, this.store, env);
                    const cryptoBoxSession = new CryptoboxSession_1.CryptoboxSession(sessionId, session);
                    return [cryptoBoxSession, decrypted];
                }
                throw new error_1.CryptoboxError('No local identity available.');
            });
        }
        session_load(sessionId) {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.log(`Trying to load Session with ID "${sessionId}"...`);
                const cachedSession = this.load_session_from_cache(sessionId);
                if (cachedSession) {
                    return cachedSession;
                }
                if (this.identity) {
                    const session = yield this.store.read_session(this.identity, sessionId);
                    const cryptoboxSession = new CryptoboxSession_1.CryptoboxSession(sessionId, session);
                    return this.save_session_in_cache(cryptoboxSession);
                }
                throw new error_1.CryptoboxError('No local identity available.');
            });
        }
        session_save(session) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.store.create_session(session.id, session.session);
                return this.save_session_in_cache(session);
            });
        }
        session_update(session) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.store.update_session(session.id, session.session);
                return this.save_session_in_cache(session);
            });
        }
        session_delete(sessionId) {
            this.remove_session_from_cache(sessionId);
            return this.store.delete_session(sessionId);
        }
        create_last_resort_prekey() {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.log(`Creating Last Resort PreKey with ID "${proteus_1.keys.PreKey.MAX_PREKEY_ID}"...`);
                this.lastResortPreKey = yield proteus_1.keys.PreKey.last_resort();
                const preKeys = yield this.store.save_prekeys([this.lastResortPreKey]);
                return preKeys[0];
            });
        }
        serialize_prekey(prekey) {
            if (this.identity) {
                return new proteus_1.keys.PreKeyBundle(this.identity.public_key, prekey).serialised_json();
            }
            throw new error_1.CryptoboxError('No local identity available.');
        }
        /**
         * Creates new PreKeys and saves them into the storage.
         */
        new_prekeys(start, size = 0) {
            return __awaiter(this, void 0, void 0, function* () {
                if (size === 0) {
                    return [];
                }
                const newPreKeys = yield proteus_1.keys.PreKey.generate_prekeys(start, size);
                return this.store.save_prekeys(newPreKeys);
            });
        }
        encrypt(sessionId, payload, preKeyBundle) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.get_session_queue(sessionId).add(() => __awaiter(this, void 0, void 0, function* () {
                    const session = preKeyBundle
                        ? yield this.session_from_prekey(sessionId, preKeyBundle)
                        : yield this.session_load(sessionId);
                    const encryptedBuffer = session.encrypt(payload);
                    yield this.session_update(session);
                    return encryptedBuffer;
                }));
            });
        }
        decrypt(sessionId, ciphertext) {
            return __awaiter(this, void 0, void 0, function* () {
                if (ciphertext.byteLength === 0) {
                    throw new DecryptionError_1.DecryptionError('Cannot decrypt an empty ArrayBuffer');
                }
                return this.get_session_queue(sessionId).add(() => __awaiter(this, void 0, void 0, function* () {
                    let session;
                    let decryptedMessage;
                    let isNewSession = false;
                    try {
                        session = yield this.session_load(sessionId);
                    }
                    catch (error) {
                        isNewSession = true;
                        [session, decryptedMessage] = yield this.session_from_message(sessionId, ciphertext);
                        this.publish_session_id(session);
                        yield this.session_save(session);
                    }
                    if (!isNewSession) {
                        decryptedMessage = yield session.decrypt(ciphertext, this.store);
                        yield this.session_update(session);
                    }
                    yield this.refill_prekeys(true);
                    return decryptedMessage;
                }));
            });
        }
        deleteData() {
            return __awaiter(this, void 0, void 0, function* () {
                this.cachedSessions = new lru_cache_1.LRUCache(DEFAULT_CAPACITY);
                this.identity = undefined;
                this.lastResortPreKey = undefined;
                this.queues = new lru_cache_1.LRUCache(DEFAULT_CAPACITY);
                yield this.store.delete_all();
            });
        }
        importIdentity(payload) {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.log('Importing local identity...');
                const identityBuffer = bazinga64_1.Decoder.fromBase64(payload).asBytes.buffer;
                const identity = proteus_1.keys.IdentityKeyPair.deserialise(identityBuffer);
                yield this.save_identity(identity);
            });
        }
        importPreKeys(serializedPreKeys) {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.log(`Importing "${Object.keys(serializedPreKeys).length}" PreKeys...`);
                const proteusPreKeys = Object.values(serializedPreKeys).map(preKey => {
                    const preKeyBuffer = bazinga64_1.Decoder.fromBase64(preKey).asBytes.buffer;
                    const proteusPreKey = proteus_1.keys.PreKey.deserialise(preKeyBuffer);
                    if (proteusPreKey.key_id === proteus_1.keys.PreKey.MAX_PREKEY_ID) {
                        this.lastResortPreKey = proteusPreKey;
                    }
                    return proteusPreKey;
                });
                yield this.store.save_prekeys(proteusPreKeys);
            });
        }
        importSessions(serializedSessions) {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.log(`Importing "${Object.keys(serializedSessions).length}" sessions...`);
                for (const sessionId in serializedSessions) {
                    const serializedSession = serializedSessions[sessionId];
                    const sessionBuffer = bazinga64_1.Decoder.fromBase64(serializedSession).asBytes.buffer;
                    const proteusSession = proteus_1.session.Session.deserialise(this.identity, sessionBuffer);
                    const cryptoBoxSession = new CryptoboxSession_1.CryptoboxSession(sessionId, proteusSession);
                    yield this.session_save(cryptoBoxSession);
                }
            });
        }
        deserialize(payload) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.deleteData();
                yield this.importIdentity(payload.identity);
                yield this.importPreKeys(payload.prekeys);
                yield this.importSessions(payload.sessions);
                yield this.refill_prekeys(true);
            });
        }
        serialize() {
            return __awaiter(this, void 0, void 0, function* () {
                const toBase64 = (buffer) => bazinga64_1.Encoder.toBase64(buffer).asString;
                const data = {
                    identity: '',
                    prekeys: {},
                    sessions: {},
                };
                const identity = yield this.store.load_identity();
                if (identity) {
                    data.identity = toBase64(identity.serialise());
                    const sessions = yield this.store.read_sessions(identity);
                    for (const sessionId in sessions) {
                        const storedSession = sessions[sessionId];
                        data.sessions[sessionId] = toBase64(storedSession.serialise());
                    }
                }
                const storedPreKeys = yield this.store.load_prekeys();
                for (const storedPreKey of storedPreKeys) {
                    data.prekeys[storedPreKey.key_id] = toBase64(storedPreKey.serialise());
                }
                return data;
            });
        }
    }
    Cryptobox.VERSION = version;
    Cryptobox.TOPIC = TOPIC;
    return Cryptobox;
})();
exports.Cryptobox = Cryptobox;
//# sourceMappingURL=Cryptobox.js.map