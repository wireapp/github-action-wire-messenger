/// <reference types="node" />
import { keys as ProteusKeys } from '@wireapp/proteus';
import { CRUDEngine } from '@wireapp/store-engine';
import { EventEmitter } from 'events';
import { CryptoboxSession } from './CryptoboxSession';
import { SerializedCryptobox } from './SerializedCryptobox';
declare enum TOPIC {
    NEW_PREKEYS = "new-prekeys",
    NEW_SESSION = "new-session"
}
export interface Cryptobox {
    on(event: TOPIC.NEW_PREKEYS, listener: (prekeys: ProteusKeys.PreKey[]) => void): this;
    on(event: TOPIC.NEW_SESSION, listener: (session: string) => void): this;
}
export declare class Cryptobox extends EventEmitter {
    private cachedSessions;
    private queues;
    private readonly logger;
    private readonly minimumAmountOfPreKeys;
    private readonly store;
    static VERSION: string;
    static readonly TOPIC: typeof TOPIC;
    lastResortPreKey: ProteusKeys.PreKey | undefined;
    identity: ProteusKeys.IdentityKeyPair | undefined;
    constructor(engine: CRUDEngine, minimumAmountOfPreKeys?: number);
    private get_session_queue;
    private save_session_in_cache;
    private load_session_from_cache;
    private remove_session_from_cache;
    create(): Promise<ProteusKeys.PreKey[]>;
    load(): Promise<ProteusKeys.PreKey[]>;
    private init;
    get_serialized_last_resort_prekey(): Promise<{
        id: number;
        key: string;
    }>;
    get_prekey(prekey_id?: number): Promise<ProteusKeys.PreKey | undefined>;
    get_prekey_bundle(preKeyId?: number): Promise<ProteusKeys.PreKeyBundle>;
    get_serialized_standard_prekeys(): Promise<{
        id: number;
        key: string;
    }[]>;
    private publish_event;
    private publish_prekeys;
    private publish_session_id;
    /**
     * This method returns all PreKeys available, respecting the minimum required amount of PreKeys.
     * If all available PreKeys don't meet the minimum PreKey amount, new PreKeys will be created.
     */
    private refill_prekeys;
    private create_new_identity;
    private save_identity;
    /**
     * Creates (and persists) a new session which can be used for cryptographic operations (encryption & decryption) from
     * a remote PreKey bundle. This function is automatically called on every execution of "encrypt" and "decrypt" so you
     * might not need to call it yourself. However, it has been marked as "public" because there are some cases where you
     * just need the session without executing an encryption or decryption. This is the case when you for example just
     * want to show the fingerprint of the remote party.
     */
    session_from_prekey(sessionId: string, preKeyBundle: ArrayBuffer): Promise<CryptoboxSession>;
    /**
     * Uses a cipher message to create a new session and to decrypt to message which the given cipher message contains.
     * Saving the newly created session is not needed as it's done during the inbuilt decryption phase.
     */
    private session_from_message;
    session_load(sessionId: string): Promise<CryptoboxSession>;
    private session_save;
    private session_update;
    session_delete(sessionId: string): Promise<string>;
    private create_last_resort_prekey;
    serialize_prekey(prekey: ProteusKeys.PreKey): {
        id: number;
        key: string;
    };
    /**
     * Creates new PreKeys and saves them into the storage.
     */
    private new_prekeys;
    encrypt(sessionId: string, payload: string | Uint8Array, preKeyBundle?: ArrayBuffer): Promise<ArrayBuffer>;
    decrypt(sessionId: string, ciphertext: ArrayBuffer): Promise<Uint8Array>;
    private deleteData;
    private importIdentity;
    private importPreKeys;
    private importSessions;
    deserialize(payload: SerializedCryptobox): Promise<void>;
    serialize(): Promise<SerializedCryptobox>;
}
export {};
